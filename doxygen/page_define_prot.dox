/// @page page_define_prot How to Define New Custom Protocol
/// @tableofcontents
/// The protocol definition is mostly about defining messages and their fields.
/// As the first stage please read @ref page_field_tutorial in order to understand
/// what types of fields are available and how to define them.
///
/// @section page_define_prot_headers Headers and Libraries
/// COMMS is a headers only library without any object files to link against. 
/// In order to include the whole functionality of the library please use
/// single include statement:
/// @code
/// #include "comms/comms.h"
/// @endcode
///
/// If the protocol grows and the compilation takes a significant amount of time,
/// more fine-grained include statements may be used:
/// @code
/// #include "comms/fields.h" // Provides all definitions from comms::field namespace
/// #include "comms/frames.h" // Provides all definitions from comms::frame namespace
/// #include "comms/units.h" // Provides all definitions from comms::units namespace
/// #include "comms/Message.h" // Definition of comms::Message class to define interface
/// #include "comms/MessageBase.h" // Definition of comms::MessageBase class to define message impl
/// #include "comms/GenericHandler.h" // Definition of comms::GenericHandler class
/// #include "comms/MsgFactory.h" // Definition of comms::MessageFactory class
/// @endcode
///
/// @section page_define_prot_conditions Checking pre- and post- Conditions
/// The COMMS library is intended to be used in embedded systems (including 
/// bare metal), which may have standard library excluded from the compilation.
/// In order to check pre- and post- conditions as well as inner assumptions, please
/// use @ref COMMS_ASSERT macro (instead of standard @b assert()). 
/// It gives and ability to the application being developed
/// in the future to choose and use its own means to report assertion failures.
///
/// @section page_define_prot_options Configuration Options
/// Many classes provided by the @b COMMS library allow change and/or extention
/// of their default functionality using various options. The option classes and/or
/// types that can (and should) be used to define a protocol reside in 
/// @ref comms::option::def namespace. All option classes / types that intended to be used by
/// the end application for its own customization reside in @ref comms::option::app
/// namespace and should @b NOT be used in protocol definition.
///
/// @section page_define_prot_interface Common Interface Class
/// Protocol definition needs to be started by defining all the available 
/// numeric IDs of the messages as separate enum. For example in file @b MsgId.h
/// @code
/// // file MsgId.h
/// #pragma once
/// #include <cstdint>
///
/// namespace my_protocol
/// {
///     enum MsgId : std::uint8_t
///     {
///         MsgId_Message1,
///         MsgId_Message2,
///         MsgId_Message3,
///         ...
///     };
/// } // namespace my_protocol
/// @endcode
/// @b NOTE, that most probably the same enum will be used to define a field that
/// responsible to read / write message ID information in the transport framing. That's
/// the reason why the underlying type of the enum needs to be specified (please
/// see @ref sec_field_tutorial_enum_value for more details).
///
/// After the numeric IDs are specified, there is a need to define common
/// message interface class by extending @ref comms::Message. 
/// The defined class / type needs to pin the type used for message IDs 
/// with @ref comms::option::def::MsgIdType and defined
/// earlier enum. It also should specify the serialisation endian with either
/// @ref comms::option::def::BigEndian or @ref comms::option::def::LittleEndian options.
/// However it must also
/// allow extension with other options by the application. 
/// @code
/// // file Message.h
/// #pragma once
/// namespace my_protocol
/// {
/// 
/// template <typename... TOptions>
/// using Message = 
///     comms::Message<
///         comms::option::def::BigEndian,
///         comms::option::def::MsgIdType<MsgId>,
///         TOptions...
///     >;
///
/// } // namespace my_protocol
/// @endcode
/// The application, that is going to use protocol definition later, will use
/// extra options to specify polymorphic behaviour it needs.
///
/// @subsection page_define_prot_interface_extra_transport Extra Transport Values
/// Some protocols may use extra values in their transport information, which
/// may influence the way how message payload is being read and/or message 
/// object being handled. Good example would be having a protocol version, which
/// defines what message payload fields were serialised and which were not (because
/// they were introduced in later version of the protocol). Another example is
/// having some kind of flags relevant to all the messages.
/// Such extra information needs to be stored in the message object itself.
/// The most straightforward way of achieving this is to define appropriate API
/// functions and member fields in common message interface class:
/// @code
/// // file Message.h
/// #pragma once
/// namespace my_protocol
/// {
/// 
/// template <typename... TOptions>
/// class MyMessage : public 
///     comms::Message<
///         comms::option::def::BigEndian,
///         comms::option::def::MsgIdType<MsgId>,
///         TOptions...
///     >
/// {
/// public:
///     unsigned getVersion() const { return m_version; }
///     void setVersion(unsigned value) { m_version = value; }
///     std::uint8_t getFlags() const { return m_flags; }
///     void setFlags(std::uint8_t value) { m_flags = value; }
/// private:
///     unsigned m_version = 0;
///     std::uint8_t m_flags = 0;
/// };
///
/// } // namespace my_protocol
/// @endcode
/// @b HOWEVER, it will require implementation of a custom protocol transport layer
/// (See @ref page_frame_tutorial_new_layers) that read the required values
/// and re-assign them to the message object using appropriate API function. The
/// COMMS library has a built-in way to automate such assignments (see 
/// @ref page_frame_tutorial_transport_value section in @ref page_frame_tutorial). 
/// In order to support usage
/// of @ref comms::frame::TransportValueLayer the message interface class must
/// define "extra transport fields".
///
/// First, such extra transport field(s) must be defined using a field abstraction
/// (see @ref page_field_tutorial) and bundled in @b std::tuple:
/// @code
/// namespace my_protocol
/// {
/// 
/// // Base class of all the fields
/// using MyFieldBase = comms::Field<comms::option::def::BigEndian>;
///
/// // Field describing protocol version.
/// using MyVersionField = comms::field::IntValue<MyFieldBase, std::uint16_t>;
///
/// // Field describing protocol version.
/// using MyFlagsField = comms::field::BitmaskValue<MyFieldBase, comms::option::def::FixedLength<1> >;
///
/// // Relevant extra transport fields, bundled in std::tuple
/// using MyExtraTransportFields =
///     std::tuple<
///         MyVersionField,
///         MyFlagsField
///     >;
///
/// } // namespace my_protocol
/// @endcode
/// Second, provide the defined tuple to message interface class using 
/// @ref comms::option::def::ExtraTransportFields option.
/// @code
/// namespace my_protocol
/// {
/// 
/// template <typename... TOptions>
/// class Message : public
///     comms::Message<
///         comms::option::def::BigEndian,
///         comms::option::def::MsgIdType<MsgId>,
///         comms::option::def::ExtraTransportFields<MyExtraTransportFields>,
///         TOptions...
///     >
/// {
/// };
///
/// } // namespace my_protocol
/// @endcode
/// It is equivalent to having the following public interface defined:
/// @code
/// namespace my_protocol
/// {
/// 
/// template <typename... TOptions>
/// class MyMessage : public 
///     comms::Message<
///         comms::option::def::BigEndian,
///         comms::option::def::MsgIdType<MsgId>,
///         TOptions...
///     >
/// {
/// public:
///     // Type of extra fields
///     using TransportFields = MyExtraTransportFields;
///
///     // Accessors for defined transport fields
///     TransportFields& transportFields() { return m_transportFields; }
///     const TransportFields& transportFields() const { return m_transportFields; }
///
/// private:
///     TransportFields m_transportFields;
/// };
///
/// } // namespace my_protocol
/// @endcode
/// An access to the version and flags information, given a reference to the message object
/// will look like this:
/// @code
/// void handle(my_protocol::Message<>& msg)
/// {
///     // Access to tuple of extra transport fields
///     auto& extraTransportFields = msg.transportFields();
///
///     // Access the version field
///     auto& versionField = std::get<0>(extraTransportFields);
///
///     // Retrieve the version numeric value
///     auto versionValue = versionField.value();
///
///     // Access the flags field
///     auto& flagsField = std::get<1>(extraTransportFields);
///
///     ... // do something with version and flags information
/// }
/// @endcode
/// The version and/or flags information may be accessed in the same way when implementing
/// @ref page_define_prot_message_base_custom_read and acted accordingly.
///
/// @b NOTE, that example above accesses the index of the field within the holding
/// tuple. For convenience, the COMMS library defines 
/// #COMMS_MSG_TRANSPORT_FIELDS_NAMES() macro which allows providing meaningful
/// names to the extra transport fields:
/// @code
/// template <typename... TOptions>
/// class Message : public
///     comms::Message<
///         comms::option::def::BigEndian,
///         comms::option::def::MsgIdType<MsgId>,
///         comms::option::def::ExtraTransportFields<MyExtraTransportFields>,
///         TOptions...
///     >
/// {
///     // (Re)definition of the base class as inner Base type is
///     // required by COMMS_MSG_TRANSPORT_FIELDS_NAMES() macro
///     using Base = comms::Message<...>;
/// public:
///     COMMS_MSG_TRANSPORT_FIELDS_NAMES(version, flags)
/// };
/// @endcode
/// @b NOTE requirement to (re)define base class as inner @b Base type. It is
/// needed to be able to access @ref comms::Message::TransportFields "TransportFields"
/// type defined by the @ref comms::Message.
///
/// Using such macro is equivalent to manually defining the following public
/// interface:
/// @code
/// template <typename... TOptions>
/// class Message : public
///     comms::Message<
///         comms::option::def::BigEndian,
///         comms::option::def::MsgIdType<MsgId>,
///         comms::option::def::ExtraTransportFields<MyExtraTransportFields>,
///         TOptions...
///     >
/// {
/// public:
///     enum TransportFieldIdx
///     {
///         TransportFieldIdx_version,
///         TransportFieldIdx_flags,
///         TransportFieldIdx_numOfValues
///     };
///
///     auto transportField_version() -> decltype(std::get<TransportFieldIdx_version>(transportFields()))
///     {
///         return std::get<TransportFieldIdx_version>(transportFields());
///     }
///
///     auto transportField_version() const -> decltype(std::get<TransportFieldIdx_version>(transportFields()))
///     {
///         return std::get<TransportFieldIdx_version>(transportFields());
///     }
///
///     auto transportField_flags() -> decltype(std::get<TransportFieldIdx_flags>(transportFields()))
///     {
///         return std::get<TransportFieldIdx_flags>(transportFields());
///     }
///
///     auto transportField_flags() const -> decltype(std::get<TransportFieldIdx_flags>(transportFields()))
///     {
///         return std::get<TransportFieldIdx_flags>(transportFields());
///     }
///
///     // Definition of the transport field's types
///     using TransportField_version = ...;
///     using TransportField_flags = ...;
/// };
/// @endcode
/// @b NOTE, that the defined "extra transport fields" are there to attach 
/// some extra information, delivered as part of transport framing, to message 
/// object itself. These fields are @b NOT getting serialised / deserialised when message
/// object being read / written.
///
/// <b>SIDE NOTE:</b> In addition to #COMMS_MSG_TRANSPORT_FIELDS_NAMES() macro
/// there is #COMMS_MSG_TRANSPORT_FIELDS_ACCESS() one. It is very similar to
/// #COMMS_MSG_TRANSPORT_FIELDS_NAMES() but does @b NOT (re)define the inner @b TransportField_*
/// types. It also does not require (except for @b clang) having base class to
/// be (re)defined as inner @b Base type.
/// @code
/// template <typename... TOptions>
/// class Message : public
///     comms::Message<
///         comms::option::def::BigEndian,
///         comms::option::def::MsgIdType<MsgId>,
///         comms::option::def::ExtraTransportFields<MyExtraTransportFields>,
///         TOptions...
///     >
/// {
/// public:
///     COMMS_MSG_TRANSPORT_FIELDS_ACCESS(version, flags)
/// };
/// @endcode
/// In fact #COMMS_MSG_TRANSPORT_FIELDS_NAMES() is implemented as the wrapper 
/// around #COMMS_MSG_TRANSPORT_FIELDS_ACCESS().
///
/// @subsection page_define_prot_interface_version Version in Extra Transport Values
/// As was described in previous section, the extra transport values may contain
/// protocol version information. The COMMS library contains extra functionality
/// to help with protocol versioning. If extra transport values contain version,
/// then it is recommended to let the library know which field in the provided
/// ones is the version. To do so @ref comms::option::def::VersionInExtraTransportFields,
/// with index of the field as a template argument needs to be used.
/// @code
/// template <typename... TOptions>
/// class Message : public
///     comms::Message<
///         comms::option::def::BigEndian,
///         comms::option::def::MsgIdType<MsgId>,
///         comms::option::def::ExtraTransportFields<MyExtraTransportFields>,
///         comms::option::def::VersionInExtraTransportFields<0>,
///         TOptions...
///     >
/// {
/// public:
///     ...
/// };
/// @endcode
/// This option adds the following type and convenience access member functions.
/// @code
/// template <typename... TOptions>
/// class Message : public
///     comms::Message<...>
/// {
/// public:
///     ...
///     // Type used for version storage
///     using VersionType = ...;
/// 
///     // Convenience access to the version value
///     VersionType& version();
///     const VersionType& version() const;
/// };
/// @endcode
/// If message contents depend on the version of the protocol, this information
/// will be used inside @ref page_define_prot_message_base (described below) to
/// properly implement various functionalities. More details in @ref 
/// page_define_prot_message_version section below. 
///
/// @section page_define_prot_message_base Message Implementation Class
/// The next stage is to define protocol messages with their fields.
/// 
/// <b>Recommended Practice</b>
/// @li Use separate header file for every message class.
/// @li Use separate folder and/or namespace for all the messages (for example @b message)
/// @li Define all the relevant to the message fields in the same file, but 
///     in separate scope (struct), that has the same name as the message, but 
///     has extra suffix (@b *Fields).
/// @li Define inner type (for example @b All) that bundles all the defined fields
///     in single @b std::tuple.
///
/// For example, let's assume there is a protocol message called "Message1". Then,
/// define it in separate header filed (@b Message1.h)
/// @code
/// #pragma once
/// #include "comms/comms.h"
///
/// #include "MyFieldBase.h" // Defines MyFieldBase common base class for all the fields
///
/// namespace my_protocol
/// {
/// 
/// namespace message
/// {
///
/// struct Message1Fields
/// {
///     using field1 = comms::field::IntValue<MyFieldBase, std::uint16_t>;
///     using field2 = ...
///     using field3 = ...
///
///     // bunding type
///     using All = 
///         std::tuple<
///             field1,
///             field2,
///             field3
///         >;
/// };
///
/// // Definition of the message itself, described and explained later
/// template <typename TBase>
/// class Message1 : public comms::MessageBase<TBase, ...> 
/// {
///     ...
/// };
///
/// } // namespace message
///
/// } // namespace my_protocol
/// @endcode
///
/// The message definition class has to extend @ref comms::MessageBase and receive
/// at least one template parameter, that is passed as first one to @ref comms::MessageBase.
/// @code
/// template <typename TBase>
/// class Message1 : comms::MessageBase<TBase, ...> 
/// {
///     ...
/// };
/// @endcode
/// The @b TBase template parameter is chosen by the application being developed. 
/// It is expected to be a variant of @ref page_define_prot_interface (@b my_protocol::Message),
/// which specifies polymorphic interface that needs to be implemented. 
/// The @ref comms::MessageBase class in turn will publicly inherit
/// from the provided common interface class. As the result the full class inheritance graph may look
/// like this:
/// @diafile message_class_hierarchy.dia
/// @n
///
/// There are <b>at least</b> 3 additional options that should be passed to
/// @ref comms::MessageBase.
/// @li @ref comms::option::def::StaticNumIdImpl with numeric ID of the message.
/// @li @ref comms::option::def::FieldsImpl with @b std::tuple of message fields (
///     defined earlier @b my_protocol::Message1Fields::All)
/// @li @ref comms::option::def::MsgType with actual message type (@b Message1).
///
/// For example
/// @code
/// ...
///
/// template <typename TBase>
/// class Message1 : public 
///     comms::MessageBase<
///         TBase, 
///         comms::option::def::StaticNumIdImpl<MsgId_Message1>,
///         comms::option::def::FieldsImpl<Message1Fields::All>,
///         comms::option::def::MsgType<Message1<TBase> > // type of the message being defined
/// {
///     ...
/// };
/// @endcode
///
/// It is equivalent to having the following types and @b NON-virtual functions defined
/// @code
/// template <typename TBase>
/// class Message1 : public TBase
/// {
/// public:
///     // Redefining the provided std::tuple of fields as internal type
///     using AllFields = ... /* std::tuple of fields */;
///     
///     // Access the stored std::tuple of fields
///     AllFields& fields()
///     {
///         return m_fields;
///     }
///
///     // Access the stored std::tuple of fields
///     const AllFields& fields() const
///     {
///         return m_fields;
///     }
///
///     // Default implementation of read functionality
///     template <typename TIter>
///     comms::ErrorStatus doRead(TIter& iter, std::size_t len)
///     {
///         // Read all the fields one by one by invoking
///         // read() member function of all the fields.
///     }
///
///     // Default implementation of write functionality
///     template <typename TIter>
///     comms::ErrorStatus doWrite(TIter& iter, std::size_t len) const
///     {
///         // Write all the fields one by one by invoking
///         // write() member function of all the fields.
///     }
///
///     // Default implementation of validity check functionality
///     bool doValid() const
///     {
///         // Call to valid() member function of all the fields one by one.
///         // The message is valid if all the fields are valid.
///     }
///
///     // Default implementation of length calculation functionality
///     std::size_t doLength() const
///     {
///         // Invoke the length() member function of every field and
///         // report sum of the values
///     }
///
///     // Defalut implementation of the refreshing functionality
///     bool doRefresh()
///     {
///         // Invokes refresh() member function of every field and returns
///         // true if at least one of the fields has been updated (returned true).
///     }
///
/// private:
///     AllFields m_fields; // Fields stored as tuple.
/// };
/// @endcode
/// See also relevant API documentation:
/// @li @ref comms::MessageBase::fields()
/// @li @ref comms::MessageBase::doRead()
/// @li @ref comms::MessageBase::doWrite()
/// @li @ref comms::MessageBase::doLength()
/// @li @ref comms::MessageBase::doValid()
/// @li @ref comms::MessageBase::doRefresh()
///
/// In case the passed message interface class as template parameter (@b TBase)
/// defines some polymorphic interface functions, their implementation is automatically
/// generated by the @ref comms::MessageBase. For example if passed interface
/// class required polymorphic read operation, the following member function will
/// also be automatically implemented:
/// @code
/// template <typename TBase>
/// class Message1 : public TBase
/// {
///     ...
/// protected:
///     virtual comms::ErrorStatus readImpl(ReadIterator& iter, std::size_t len)
///     {
///         return doRead(iter, len);
///     }
/// };
/// @endcode
///
/// @subsection page_define_prot_message_base_field_names Providing Names to the Fields
/// When preparing message object to send or when handling received message, the
/// fields it contains need to be accessed to set or get their values. The default
/// (build-in) way of achieving that is to get access to the fields tuple 
/// using inherited comms::MessageBase::fields() member function and then using
/// @b std::get() function to access the fields inside the tuple.
/// @code
/// Message1<SomeInterface> msg;
/// auto& allFields = msg.fields();
/// auto& field1 = std::get<0>(allFields);
/// auto& field2 = std::get<1>(allFields);
///
/// field1.value() = 100;
/// field2.value() = 32;
/// sendMessage(msg);
/// @endcode
/// Although it works, it is not very convenient way to access and operate the fields.
/// There is #COMMS_MSG_FIELDS_NAMES() macro that allows to provide meaningful names
/// for the fields:
/// @code
/// template <typename TMessage>
/// class Message1 : public
///     comms::MessageBase<... /* options here */>
/// {
///     // Definition of the Base class is a requirement
///     using Base = comms::MessageBase<... /* options here */>;
/// public:
///     // Provide names for the fields
///     COMMS_MSG_FIELDS_NAMES(value1, value2, value3);
/// };
/// @endcode
/// @b NOTE requirement to (re)define base class as inner @b Base type. It is
/// needed to be able to access @ref comms::MessageBase::AllFields "AllFields"
/// type defined by the @ref comms::MessageBase.
///
/// The said macro creates the following definitions of inner enum @b FieldIdx
/// type, @b field_* accessor functions as well as @b Field_* type definitions.
/// @code
/// template <typename TMessage>
/// class Message1 : public
///     comms::MessageBase<... /* options here */>
/// {
/// public:
///     enum FieldIdx
///     {
///         FieldIdx_value1,
///         FieldIdx_value2,
///         FieldIdx_value3,
///         FieldIdx_numOfValues
///     }
///
///     // Access the "value1" field
///     auto field_value1() -> decltype(std::get<FieldIdx_value1>(fields()))
///     {
///         return std::get<FieldIdx_value1>(fields());
///     }
///
///     // Access the "value1" field (const variant)
///     auto field_value1() const -> decltype(std::get<FieldIdx_value1>(fields()))
///     {
///         return std::get<FieldIdx_value1>(fields());
///     }
///
///     // Access the "value2" field
///     auto field_value2() -> decltype(std::get<FieldIdx_value2>(fields()))
///     {
///         return std::get<FieldIdx_value2>(fields());
///     }
///
///     // Access the "value2" field (const variant)
///     auto field_value2() const -> decltype(std::get<FieldIdx_value2>(fields()))
///     {
///         return std::get<FieldIdx_value2>(fields());
///     }
///
///     // Access the "value3" field
///     auto field_value3() -> decltype(std::get<FieldIdx_value3>(fields()))
///     {
///         return std::get<FieldIdx_value3>(fields());
///     }
///
///     // Access the "value3" field (const variant)
///     auto field_value3() const -> decltype(std::get<FieldIdx_value3>(fields()))
///     {
///         return std::get<FieldIdx_value3>(fields());
///     }
///
///     // Definition of the field's types
///     using Field_value1 = Field1;
///     using Field_value2 = Field2;
///     using Field_value3 = Field3;
/// };
/// @endcode
/// As the result, accessing to the fields becomes much easier and clearer:
/// @code
/// Message1<SomeInterface> msg;
/// msg.field_value1().value() = 100;
/// msg.field_value2().value() = 32;
/// sendMessage(msg);
/// @endcode
/// <b>SIDE NOTE:</b> In addition to #COMMS_MSG_FIELDS_NAMES() macro
/// there is #COMMS_MSG_FIELDS_ACCESS() one. It is very similar to
/// #COMMS_MSG_FIELDS_NAMES() but does @b NOT (re)define the inner @b Field_*
/// types. It also does not require (except for @b clang) having base class to
/// be (re)defined as inner @b Base type.
/// @code
/// template <typename TMessage>
/// class Message1 : public
///     comms::MessageBase<... /* options here */>
/// {
/// public:
///     // Provide names for the fields
///     COMMS_MSG_FIELDS_ACCESS(value1, value2, value3);
/// };
/// @endcode
/// In fact #COMMS_MSG_FIELDS_NAMES() is implemented as the wrapper 
/// around #COMMS_MSG_FIELDS_ACCESS().
///
/// @subsection page_define_prot_message_base_custom_read Custom Read Functionality
/// The default read functionality implemented by @ref comms::MessageBase::doRead()
/// is to invoke @b read() member function of every field and return @b success
/// if all the invocations returned @b success.
/// Sometimes such default implementation may be incomplete or incorrect and may require
/// additional or different implementation. It is very easy to fix by defining
/// new @b doRead() public member function with updated functionality. The 
/// @ref comms::MessageBase class contains inner "magic" to call the provided @b doRead()
/// instead of default one when implementing virtual @ref comms::MessageBase::readImpl(). 
/// As an example let's define new message
/// type (@b Message2), which has two fields. The first one is a 1 byte bitmask,
/// the least significant bit of which defines whether the second field exists.
/// The second field is optional 2 byte unsigned integer one.
/// @code
/// // file Message2.h
///
/// #include "comms/comms.h"
/// 
/// #include "MyFieldBase.h" // Defines MyFieldBase common base class for all the fields
///
/// namespace my_protocol
/// {
/// 
/// namespace message
/// {
///
/// class Message2Fields
/// {
///     using field1 =     
///         comms::field::BitmaskValue<
///             MyFieldBase, 
///             comms::option::def::FixedLength<1>,
///             comms::option::def::BitmaskReservedBits<0xfe, 0> 
///         >;
///
///     using field2 = 
///         comms::field::Optional<
///             comms::field::IntValue<MyFieldBase, std::uint16_t>,
///             comms::option::def::MissingByDefault
///         >;
///
///     // bundle all the fields
///     using All = std::tuple<
///         field1,
///         field2
///     >;
/// };
///
/// template <typename TBase>
/// class Message2 : public
///     comms::MessageBase<
///         TBase, 
///         comms::option::def::StaticNumIdImpl<MsgId_Message2>, 
///         comms::option::def::FieldsImpl<Message2Fields::All>,
///         comms::option::def::MsgType<Message2<TBase> >
///     >
/// {
///     // Redefinition of the base class as inner Base type, required
///     // by COMMS_MSG_FIELDS_NAMES() macro.
///     using Base = 
///         comms::MessageBase<
///             TBase, 
///             comms::option::def::StaticNumIdImpl<MsgId_Message2>, 
///             comms::option::def::FieldsImpl<Message2Fields::All>,
///             comms::option::def::MsgType<Message2<TBase> >
///         >;
/// public:
///     COMMS_MSG_FIELDS_NAMES(flags, data);
///     
///     template <typename TIter>
///     comms::ErrorStatus doRead(TIter& iter, std::size_t len)
///     {
///         // Get type of the base class
///         using Base = typename std::decay<decltype(comms::toMessageBase(*this))>::type;
///
///         // Read only the flags value
///         auto es = Base::template doReadUntilAndUpdateLen<FieldIdx_data>(iter, len);
///         if (es != comms::ErrorStatus::Success) {
///             return es;
///         }
///
///         // Update mode (exists/missing) of the optional value to follow
///         if (field_flags().value() != 0) {
///             field_data().setExists();
///         else {
///             field_data().setMissing();
///         }
///     
///         // Read the rest of the fields
///         return Base::template doReadFrom<FieldIdx_data>(iter, len);
///     }
/// };
/// @endcode
/// Please @b note, that due to the fact that defined message class is a template one, the member
/// functions defined in @ref comms::MessageBase are not accessible directly, there
/// is a need to specify the base class scope. If there is no inner @b Base
/// type defined in the class scope (required to support clang and earlier versions of gcc), 
/// it is possible to use @ref comms::toMessageBase()
/// function to detect it.
///
/// Also @b note, that comms::MessageBase provides the following member functions
/// in order to allow read of the selected fields.
/// @li @ref comms::MessageBase::doReadFrom()
/// @li @ref comms::MessageBase::doReadUntil()
/// @li @ref comms::MessageBase::doReadFromUntil()
/// @li @ref comms::MessageBase::doReadFromAndUpdateLen()
/// @li @ref comms::MessageBase::doReadUntilAndUpdateLen()
/// @li @ref comms::MessageBase::doReadFromUntilAndUpdateLen()
///
/// @subsection page_define_prot_message_base_custom_refresh Custom Refresh Functionality
/// The default refresh functionality implemented by @ref comms::MessageBase::doRefresh()
/// is to invoke @b refresh() member function of every field. The function will
/// return @b true (indicating that at message contents have been updated) if
/// at least one of the fields returns @b true. 
/// Let's take a look again at the definition of @b Message2 mentioned earlier, where
/// the existence of second field (@b data) depends on the value of the least
/// significant bit in the first field (@b flags). During read operation the
/// mode of the @b data is updated after value of the @b flags is read. However,
/// when preparing the same message for write, there is a chance that message 
/// contents are going to be put in invalid state:
/// @code
/// Message2<SomeInterface> msg;
/// msg.field_flags().value() = 0x1;
/// msg.field_data().field().value() = 10U;
/// msg.field_data().setMissing(); // Bug, the field should exist
/// sendMessage(msg);
/// @endcode
/// If message is sent, the @b flags will indicate that the @b data field follows,
/// but it won't be serialised, due to being marked as "missing" by mistake. Please note,
/// that all the "write" functions are marked as @b const and are not allowed
/// to update the message fields during write operation. It may be useful to have
/// member function that brings message contents into the valid and consistent
/// state. It should be called @b doRefresh() and return boolean value (@b true
/// in case the message contents were updated, and @b false if they remain
/// intact.
/// @code
/// template <typename TBase>
/// class Message2 : public comms::MessageBase<... /* options here */>
/// {
///     using Base = comms::MessageBase<... /* options here */>;
/// public:
///     COMMS_MSG_FIELDS_NAMES(flags, data);
///     
///     bool doRefresh()
///     {
///         auto expectedDataMode = comms::field::OptionalMode::Missing;
///         if ((field_flags().value() & 0x1) != 0U) {
///             expectedDataMode = comms::field::OptionalMode::Exists;
///         }
///
///         if (field_data().getMode() == expectedDataMode) {
///             // No need to change anything
///             return false;
///         }
///
///         field_data().setMode(expectedDataMode);
///         return true;
///     }
/// };
/// @endcode
/// As the result the code preparing message for sending may look like this:
/// @code
/// Message2<SomeInterface> msg;
/// msg.field_flags().value() = 0x1;
/// msg.field_data().field().value() = 10U;
/// msg.doRefresh(); // Bring message contents into a valid state
/// sendMessage(msg);
/// @endcode
/// In order to support polymorphic refresh functionality when required (see
/// @ref page_use_prot_interface_refresh), the actual message class
/// implementation must also pass @ref comms::option::def::HasCustomRefresh option to
/// @ref comms::MessageBase class. Failure to do so @b may result in missing
/// implementation of @ref comms::MessageBase::refreshImpl(). In this case,
/// the default implementation of @ref comms::Message::refreshImpl() will be
/// used instead, always
/// returning @b false (reporting that message fields weren't updated) without proper execution
/// of refresh functionality.
/// @code
/// template <typename TBase>
/// class Message2 : public
///     comms::MessageBase<
///         TBase, 
///         comms::option::def::StaticNumIdImpl<MyMsgId_Message2>, 
///         comms::option::def::MsgType<Message2<TMessage> >, 
///         comms::option::def::FieldsImpl<Message2Fields> ,
///         comms::option::def::HasCustomRefresh // Support polymorphic refresh when needed
///     >
/// {
///     using Base = comms::MessageBase<... /* options here */>;
/// public:
///     COMMS_MSG_FIELDS_NAMES(flags, data);
///     
///     template <typename TIter>
///     comms::ErrorStatus doRead(TIter& iter, std::size_t len)
///     {
///         ... // see implementation above
///     }
///
///     bool doRefresh()
///     {
///         ... // see implementation above
///     }
/// };
/// @endcode
///
/// @subsection page_define_prot_message_base_custom_write Custom Write Functionality
/// Usually there is no need to provide custom write functionality for the messages
/// in consistent state (see @ref page_define_prot_message_base_custom_refresh).
/// The default one implemented by @ref comms::MessageBase::doWrite(), which invokes
/// @b write() member function of every field, is correct. However, if 
/// the need arises it is enough just to provide custom @b doWrite() member
/// function.
/// @code
/// template <typename TBase>
/// class SomeMessage : public comms::MessageBase<...>
/// {
///     using Base = comms::MessageBase<...>;
/// public:
///     COMMS_MSG_FIELDS_NAMES(...);
///     
///     template <typename TIter>
///     comms::ErrorStatus doWrite(TIter& iter, std::size_t len) const
///     {
///         ... 
///     }
/// };
/// @endcode
/// @b Note, that comms::MessageBase provides the following member functions
/// in order to allow write of the selected fields.
/// @li @ref comms::MessageBase::doWriteFrom()
/// @li @ref comms::MessageBase::doWriteUntil()
/// @li @ref comms::MessageBase::doWriteFromUntil()
/// @li @ref comms::MessageBase::doWriteFromAndUpdateLen()
/// @li @ref comms::MessageBase::doWriteUntilAndUpdateLen()
/// @li @ref comms::MessageBase::doWriteFromUntilAndUpdateLen()
///
/// @subsection page_define_prot_message_base_custom_length Custom Length Calculation
/// Just like with @ref page_define_prot_message_base_custom_write providing
/// custom length calculation is usually not required, but if need arises, just
/// provide your own variant of @b doLength() member function.
/// @code
/// template <typename TBase>
/// class SomeMessage : public comms::MessageBase<...>
/// {
/// public:
///     std::size_t doLength() const
///     {
///         ... 
///     }
/// };
/// @endcode
/// @b Note, that comms::MessageBase provides the following member functions
/// in order to allow length calculation of the selected fields.
/// @li @ref comms::MessageBase::doLengthFrom()
/// @li @ref comms::MessageBase::doLengthUntil()
/// @li @ref comms::MessageBase::doLengthFromUntil()
/// @li @ref comms::MessageBase::doMinLengthFrom()
/// @li @ref comms::MessageBase::doMinLengthUntil()
/// @li @ref comms::MessageBase::doMinLengthFromUntil()
/// @li @ref comms::MessageBase::doMaxLengthFrom()
/// @li @ref comms::MessageBase::doMaxLengthUntil()
/// @li @ref comms::MessageBase::doMaxLengthFromUntil()
///
/// @subsection page_define_prot_message_base_custom_valid Custom Validity Check
/// The default implementation of @ref comms::MessageBase::doValid() calls 
/// @b valid() member function of every message field and returns @b true if
/// all the calls returned @b true. However, there may be a need to provide extra
/// checks in case specific value of one field may require tighter constrains on
/// the value of another. In order to provide custom validity check, just implement
/// custom @b doValid() member function.
/// @code
/// template <typename TBase>
/// class SomeMessage : public comms::MessageBase<...>
/// {
/// public:
///     bool doValid() const
///     {
///         // Get type of the base class
///         using Base = typename std::decay<decltype(comms::toMessageBase(*this))>::type;
///         
///         // Check that all fields are valid by themselves
///         if (!Base::doValid()) {
///             return false;
///         }
/// 
///         ... // do custom validation logic
///         return true;
///     }
/// };
/// @endcode
///
/// @subsection page_define_prot_message_base_name Reporting Message Name
/// Some application may require printing (or reporting by other means) human
/// readable name of the message. The @ref comms::MessageBase cannot automatically
/// generate appropriate function. As the result, the message definition class is
/// expected to define @b doName() member function with the following signature.
/// @code
/// template <typename TBase>
/// class SomeMessage : public comms::MessageBase<...>
/// {
/// public:
///     static const char* doName()
///     {
///         return "Some Message";
///     }
/// };
/// @endcode
/// In order to support @ref page_use_prot_interface_name there is a need
/// to pass @ref comms::option::def::HasName option to @ref comms::MessageBase to notify
/// the latter about existence of @b doName() member function.
/// @code
/// template <typename TBase>
/// class SomeMessage : public 
///     comms::MessageBase<
///         ...,
///         comms::option::def::HasName
///     >
/// {
/// public:
///     static const char* doName()
///     {
///         return "Some Message";
///     }
/// };
/// @endcode
/// When @ref comms::option::def::HasName is used, the @b comms::MessageBase
/// creates overriding @b nameImpl() (see @ref comms::MessageBase::nameImpl()), which
/// invokes provided @b doName() member function.
///
/// @subsection page_define_prot_message_version Protocol Version Support
/// As was described earlier in @ref page_define_prot_interface_version, some 
/// protocols may include version information in either message transport framing
/// or in one of the messages used to establish a connection. Every field
/// defines @b setVersion() member function in its public interface. The 
/// comms::MessageBase class will automatically call this function for every
/// field before performing its @b read operation (inside @ref comms::MessageBase::doRead()).
/// However, if @ref page_define_prot_message_base_custom_read is implemented,
/// the latter is expected to call provided @ref comms::MessageBase::doFieldsVersionUpdate()
/// member function explicitly before attempting actual read operations. 
/// @b NOTE, that the @ref comms::MessageBase::doFieldsVersionUpdate() function
/// exists only if @ref comms::option::def::VersionInExtraTransportFields has been
/// provided to message interface.
/// @code
/// template <typename TBase>
/// class Message2 : public
///     comms::MessageBase<...>
/// {
/// public:
///     ...
///     
///     template <typename TIter>
///     comms::ErrorStatus doRead(TIter& iter, std::size_t len)
///     {
///         // Get type of the base class
///         using Base = typename std::decay<decltype(comms::toMessageBase(*this))>::type;
///         
///         // Update version of the fields
///         Base::doFieldsVersionUpdate();
///
///         // Do the actual read
///         ...
///     }
/// };
/// @endcode
/// Similarly, the fields' version needs to be updated in case 
/// @ref page_define_prot_message_base_custom_refresh is implemented.
/// @code
/// template <typename TBase>
/// class Message2 : public
///     comms::MessageBase<...>
/// {
/// public:
///     ...
///     
///     bool doRefresh()
///     {
///         // Get type of the base class
///         using Base = typename std::decay<decltype(comms::toMessageBase(*this))>::type;
///
///         // Update version of the fields
///         bool updated = Base::doFieldsVersionUpdate();
///
///         ... // Custom refresh functionality
///
///         return updated;
///     }
/// };
/// @endcode
///
/// @section page_define_prot_field_aliases Aliases to Field Names
/// When the communication protocol evolves and new versions of it are being released,
/// it may happen that some fields get renamed to give them a different or refined
/// meaning. Simple change of the name may result in old client code not being
/// able to compile with new versions of the protocol definition library. To
/// help with such case the @b COMMS library provides several macros that can generate
/// alias names for renamed fields.
///
/// @subsection page_define_prot_field_aliases_messages Aliases to Field Names Inside Message Definition
/// The @b COMMS library provides #COMMS_MSG_FIELD_ALIAS()
/// macro, which is expected to be used after #COMMS_MSG_FIELDS_NAMES() one when new
/// message class is being defined.
/// As an example let's change the @b value3 from the example in the 
/// @ref page_define_prot_message_base_field_names section to be @b newValue3.
/// @code
/// template <typename TMessage>
/// class Message1 : public comms::MessageBase<...>
/// {
///     using Base = comms::MessageBase<...>;
/// public:
///     // Provide names for the fields
///     COMMS_MSG_FIELDS_NAMES(value1, value2, newValue3);
///     COMMS_MSG_FIELD_ALIAS(value3, newValue3);
/// };
/// @endcode
/// The usage of #COMMS_MSG_FIELD_ALIAS() above generates the following alias type
/// as well as convenience access functions:
/// @code
/// template <typename TMessage>
/// class Message1 : public comms::MessageBase<...>
/// {
///     using Base = comms::MessageBase<...>;
///
/// public:
///     // Provide names for the fields
///     COMMS_MSG_FIELDS_NAMES(value1, value2, newValue3);
///
///     // Alias to the new type
///     using Field_value3 = Field_newValue3;
///     
///     // Access to "newValue3" via "value3" name
///     auto field_value3() -> decltype(field_newValue3())
///     {
///         return field_newValue3();
///     }
///
///     // Const access to "newValue3" via "value3" name
///     auto field_value3() const -> decltype(field_newValue3())
///     {
///         return field_newValue3();
///     }
/// };
/// @endcode
/// In this case the old client code that tries to access appropriate field
/// using @b field_value3() access function will still work after renaming
/// takes place.
///
/// Another common case is when some field (usually @ref comms::field::IntValue 
/// or @ref comms::field::EnumValue) has a limited range of possible values
/// and in order to save on some I/O traffic, the developer decides to split
/// the value storage into multiple small parts and make it a 
/// @ref comms::field::Bitfield instead. In order to keep old client code compiling
/// and working the #COMMS_MSG_FIELD_ALIAS() may be used:
/// @code
/// template <typename TMessage>
/// class Message1 : public comms::MessageBase<...>
/// {
///     using Base = comms::MessageBase<...>;
/// public:
///     // Provide names for the fields
///     COMMS_MSG_FIELDS_NAMES(value1, value2, newValue3);
///     COMMS_MSG_FIELD_ALIAS(value3, newValue3, member1);
/// };
/// @endcode
/// The usage of #COMMS_MSG_FIELD_ALIAS() above generates the following type and
/// convenience access functions:
/// @code
/// template <typename TMessage>
/// class Message1 : public comms::MessageBase<...>
/// {
///     using Base = comms::MessageBases<...>;
/// public:
///     // Provide names for the fields
///     COMMS_MSG_FIELDS_NAMES(value1, value2, newValue3);
///
///     // Alias to the member field
///     using Field_value3 = typename Field_newValue3::Field_member1;
///     
///     // Access to "newValue3.member1" via "value3" name
///     auto field_value3() -> decltype(field_newValue3().field_member1())
///     {
///         return field_newValue3().field_member1();
///     }
///
///     // Const access to "newValue3.member1" via "value3" name
///     auto field_value3() const -> decltype(field_newValue3().field_member1())
///     {
///         return field_newValue3().field_member1();
///     }
/// };
/// @endcode
///
/// @subsection page_define_prot_field_aliases_bundles Aliases to Field Names Inside Bundle Fields
/// Similar to defining aliases to message fields, @b COMMS library provides an ability to define
/// aliases within @ref comms::field::Bundle "bundle" field definition using
/// @ref COMMS_FIELD_ALIAS() macro.
/// @code
/// class MyBundle : public comms::field::Bundle<...>
/// {
///     // (Re)definition of the base class as inner Base type
///     using Base = comms::field::Bundle<...>;
/// public:
///     COMMS_FIELD_MEMBERS_NAMES(member1, member2, member3);
///     COMMS_FIELD_ALIAS(otherMem1Name, member1);
///     COMMS_FIELD_ALIAS(otherMem2Name, member2);
/// };
/// @endcode
///
/// @subsection page_define_prot_field_aliases_interfaces Aliases to Extra Transport Field Names Inside Interface
/// The @ref page_define_prot_interface class definition may have
/// @ref page_define_prot_interface_extra_transport. Aliasing between the 
/// extra transport fields can be defined using #COMMS_MSG_TRANSPORT_FIELD_ALIAS()
/// macro.
/// @code
/// template <typename... TOptions>
/// class Message : public
///     comms::Message<
///         comms::option::def::BigEndian,
///         comms::option::def::MsgIdType<MsgId>,
///         comms::option::def::ExtraTransportFields<MyExtraTransportFields>,
///         TOptions...
///     >
/// {
///     // (Re)definition of the base class as inner Base type.
///     using Base = comms::Message<...>;
/// public:
///     COMMS_MSG_TRANSPORT_FIELDS_NAMES(version, flags);
///     COMMS_MSG_TRANSPORT_FIELD_ALIAS(otherFlagsName, flags);    
/// };
/// @endcode
///
/// @section page_define_prot_lenth_verification Extra Compile Time Checks
/// Quite often it is obvious from the protocol specification what minimal length
/// of the serialised message contents is expected to be, and if there are not
/// variable length fields, such as @b string or @b list, then maximum serialisation
/// length is also known. It would be wise to slip in compile time checks in
/// message definition as well. There are several static constexpr member functions 
/// inherited from @b comms::MessageBase that can be used:
/// 
/// @li @ref comms::MessageBase::doMinLength()
/// @li @ref comms::MessageBase::doMaxLength()
/// @li @ref comms::MessageBase::doMinLengthFromUntil()
/// @li @ref comms::MessageBase::doMaxLengthFromUntil()
///
/// For example, the implementation of @b Message2 may be updated as below:
/// @code
/// // file Message2.h
///
/// #include "comms/comms.h"
/// 
/// #include "MyFieldBase.h" // Defines MyFieldBase common base class for all the fields
///
/// namespace my_protocol
/// {
/// 
/// namespace message
/// {
///
/// template <typename TBase>
/// class Message2 : public comms::MessageBase<...>
///     >
/// {
///     using Base =  comms::MessageBase<...>
/// public:
///     static_assert(Base::doMinLength() == 1U, "Unexpected min length");
///     static_assert(Base::doMaxLength() == 3U, "Unexpected max length");
///     ...
/// };
/// @endcode
///
/// @section page_define_prot_customisation Application Specific Customisation
/// As was mentioned in @ref page_field_tutorial, there may be a need to provide a way for
/// extra application specific customisation for used fields, especially for fields like lists
/// (@ref comms::field::ArrayList) or strings (@ref comms::field::String). By
/// default they use @b std::vector and @b std::string respectively as
/// their inner value storage types. They may be un-applicable to some aplications,
/// especially bare-metal ones. In order to solve such problem the message classes
/// are expected to receive extra template parameters, which will be propagated
/// to fields definition.
///
/// <b>Recommended Practice</b>
/// 
/// It is recommended to have a separate class / struct called @b DefaultOptions
/// wich defines relevant inner types to be @ref comms::option::app::EmptyOption (option that
/// does nothing). For example, let's assume that third field in @b Message1
/// message is a string. Then the @b DefaultOptions struct may be defined as
/// @code
/// struct DefaultOptions
/// {
///     struct message
///     {
///         struct Message1Fields
///         {
///             using field3 = comms::option::app::EmptyOption; // no extra functionality by default
///         };
///     };
/// };
/// @endcode
/// @b NOTE, that inner structure of @b DefaultOptions in not important, but it
/// is recommended to resemble the full scope of fields, options for which are
/// being prepared. Then the message definition need to be changed to receive
/// and use extra options struct.
/// @code
/// #pragma once
/// #include "comms/comms.h"
///
/// #include "MyFieldBase.h" // Defines MyFieldBase common base class for all the fields
/// #include "DefaultOptions.h" // Defines DefaultOptions struct
///
/// namespace my_protocol
/// {
/// 
/// namespace message
/// {
///
/// template <typename TOpt = DefaultOptions>
/// struct Message1Fields
/// {
///     using field1 = ...;
///     using field2 = ...
///     using field3 = 
///         comms::field::String<
///             MyFieldBase,
///             typename TOpt::message::Message1Fields::field3 // Extra option(s) 
///         >
///
///     // bunding type
///     using All = 
///         std::tuple<
///             field1,
///             field2,
///             field3
///         >;
/// };
///
/// // Definition of the message itself, described and explained later
/// template <typename TBase, typename TOpt = DefaultOptions>
/// class Message1 : public 
///     comms::MessageBase<
///         TBase, 
///         comms::option::def::StaticNumIdImpl<MsgId_Message1>,
///         comms::option::def::FieldsImpl<Message1Fields<TOpt>::All>,
///         comms::option::def::MsgType<Message1<TBase, TOpt> > 
///     >
/// {
///     ...
/// };
///
/// } // namespace message
///
/// } // namespace my_protocol
/// @endcode
/// It gives opportunity to the application to define its own single structure
/// of options for all the messages by extending the provided @b DefaultOptions 
/// and overriding selected number inner types with its own extension options.
///
/// @b NOTE, that allowing additional customisation for fields like @b list
/// (@ref comms::field::ArrayList) and @b string (@ref comms::field::String) is
/// a <b>must have</b> feature to allow usage of the same protocol definition in
/// bare-metal applications. However, it would be wise to allow extra customisation
/// for @b all the used fields, even for ones like <b>integral values</b> (@ref comms::field::IntValue)
/// or @b enum (@ref comms::field::IntValue). The client application developer
/// may want to change the default value of some field, maybe even add or
/// change (override) provided ranges of valid values, force failing of read
/// operation on invalid values, etc... @b NOTE, that when allowing such
/// customisation of fields, make sure that passed options are listed before
/// the default ones
/// @code
/// template <typename... TExtraOpts>
/// using MyField = 
///     comms::field::IntValue<
///         MyFieldBase,
///         std::uint16_t,
///         TExtraOpts..., // extra options
///         comms::option::def::DefaultNumValue<10>, // default value
///         comms::option::def::ValidNumValueRange<10, 20> // default range of valid values
///     >;
/// @endcode
/// This is because earlier used options take priority over ones used later.
///
/// Depending on the protocol there may be a need to provide additional customisation
/// for messages themselves. For example, when most messages are bi-directional
/// (which will require both read and write operation for every message) except
/// a only a few, that go only one direction (from client to server or the opposite).
/// In this case the generated code will contain implementation for
/// both polymorphic read (@ref comms::MessageBase::readImpl()) and write
/// (@ref comms::MessageBase::writeImpl()). For uni-directional messages some
/// of these function may be redundant, which unnecessary increases the binary
/// size. It may become a problem for bare-metal platforms with limited amount
/// of ROM space. The @b COMMS library provides options that may suppress automatic
/// generation of some virtual functions by the @b comms::MessageBase. The available
/// options are:
/// @li @ref comms::option::app::NoReadImpl
/// @li @ref comms::option::app::NoWriteImpl
/// @li @ref comms::option::app::NoValidImpl
/// @li @ref comms::option::app::NoLengthImpl
/// @li @ref comms::option::app::NoDispatchImpl
///
/// These options should not be used in the definition of protocol messages, but
/// it would be wise to allow the client application use them when necessary. It
/// can easily achieved using @b DefaultOptions structure described earlier.
/// @code
/// struct DefaultOptions
/// {
///     struct message
///     {
///         using Message1 = comms::option::app::EmptyOption;
///         using Message2 = comms::option::app::EmptyOption;
///         ...
///     };
/// };
/// @endcode
/// Add passing these options to message definition classes:
/// @code
/// namespace my_protocol
/// {
/// 
/// namespace message
/// {
///
/// template <typename TBase, typename TOpt = DefaultOptions>
/// class Message1 : public 
///     comms::MessageBase<
///         TBase, 
///         comms::option::def::StaticNumIdImpl<MsgId_Message1>,
///         comms::option::def::FieldsImpl<Message1Fields<TOpt>::All>,
///         comms::option::def::MsgType<Message1<TBase, TOpt> >,
///         typename TOpt::message::Message1 // Extra options 
///     >
/// {
///     ...
/// };
///
/// } // namespace message
///
/// } // namespace my_protocol
/// @endcode
///
/// @section page_define_prot_transport_framing Transport Framing Definition
/// In addition to definition of the messages and their contents, every 
/// communication protocol must ensure that the message is successfully 
/// delivered over the I/O link to the other side and recognised (based on its ID). 
/// The serialised message payload must be wrapped in some kind of transport 
/// framing prior to being sent and unwrapped on the other side when received. 
/// The @ref page_frame_tutorial page contains detailed information on
/// how define such a frame and make it usable to the client application. Note,
/// that the same protocol may be used over multiple I/O link, every one of 
/// which may require different framing. There is no limit on amount of different
/// frames that may be defined.
