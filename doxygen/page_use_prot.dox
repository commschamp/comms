/// @page page_use_prot How to Use Defined Custom Protocol
/// @tableofcontents
/// This page is oriented to client application developers. It provides instructions
/// on how to use protocol defininition after it was developed following
/// @ref page_define_prot instructions. All the examples below will use
/// @b my_protocol namespace for classes that are expectected to be already
/// defined by the custom protocol implementation.
///
/// @section page_use_prot_headers Headers and Libraries
/// The protocol definition as well as @b COMMS library are headers-only. The
/// protocol definition should already include all the required headers from
/// the @b COMMS library. The client application will have to include only relevant
/// headers from the protocol definition.
///
/// @section page_use_prot_paths Paths and Namespaces
/// All the classes provided by the @b COMMS library reside in @ref comms
/// namespace and the inner include paths start with "comms/". There may be
/// the case when this library being integrated into existing project that may already
/// define and use its own module (namespace) named @b comms. In this case it
/// should be possible to rename installation directory (@b comms to @b comms2) and 
/// to run a script after library installation to replace
/// the following strings with new name:
/// @li <b>"namespace comms"</b> - replace with "namespace comms2"
/// @li @b "comms::" - replace with "comms2::"
/// @li @b "comms/" - replace with "comms2/"
///
/// @section page_use_prot_error_handling Error Handling
/// The @b COMMS library is intended to be used in embedded systems (including 
/// bare metal), which means the library does not use exceptions to report errors.
/// The runtime errors are reported via @ref comms::ErrorStatus return values. All
/// pre- and post-conditions are checked using COMMS_ASSERT() macro.
/// It is, just like regular standard @b assert(), is compiled in if @b NDEBUG symbol
/// is not defined. In case the provided condition doesn't hold true, the macro
/// checks whether custom assertion failure behaviour was registered. If yes,
/// the registered custom assertion failure report is invoked, otherwise the
/// standard failure report used by standard @b assert() macro is used. If COMMS
/// library is used in bare metal environment without standard library, the
/// @b COMMS_NOSTDLIB symbol should be defined. In this case infinite loop is a default
/// assertion failure report behaviour.
///
/// See @ref page_assert for details on how to define custom assertion failure
/// behaviour.  
///
/// @section page_use_prot_options Configuration Options
/// The @ref page_define_prot "Protocol Definition" classes are expected to
/// define all the relevant protocol classes in a way that provides an ability to perform
/// end application specific customization, such as choice of specific data types
/// and/or necessary polymorphic interfaces. Such customization is performed by
/// passing various options defined in @ref comms::option::app namespace to 
/// the relevant class definitions.
/// The @ref comms::option::def namespace contains all the types and classes
/// relevant for the protocol definition itself. However, they can also be
/// used by the end application if need arises to introduce such modifications.
///
/// @section page_use_prot_interface Defining Message Interface Class
/// The protocol definition is expected to define extendable message interface
/// class pinning only serialisation endian and numeric message ID type (most
/// probably enum).
/// @code
/// namespace my_protocol
/// {
///     // Used IDs definition
///     enum MsgId : std::uint8_t
///     {
///         MsgId_Message1,
///         MsgId_Message2,
///         MsgId_Message3,
///         ...
///     };
///
/// template <typename... TOptions>
/// using Message = 
///     comms::Message<
///         comms::option::def::BigEndian, // endian
///         comms::option::def::MsgIdType<MsgId>, // type of message ID
///         TOptions...
///     >;
///
/// } // namespace my_protocol
/// @endcode
/// Such interface class is @b NOT polymorphic, it defines the following inner types
/// @code
/// namespace my_protocol
/// {
///     
/// class Message : public comms::Message
/// {
///     // comms::Field class with the same endian option. 
///     // Can (and should) be provided as a base class to all the
///     // fields.
///     typedef comms::Field<.../* Same endian option*/> Field;
///
///     // Type of the ID, same as the one passed with comms::option::def::MsgIdType
///     typedef MsgId MsgIdType;
///
///     // Type of the ID, when it is passed as a parameter and/or returned from the function:
///     typedef MsgId MsgIdParamType;
///
/// };
///
/// } // namespace my_protocol
/// @endcode
/// @b Note the existence of @b MsgIdType and @b MsgIdParamType. When the
/// type used for message ID is simple integral one or enum, these types
/// are equal.
/// However, if some other type is used, such as std::string, then @b MsgIdParamType
/// is a const-reference to @b MsgIdType.
///
/// The message interface class may be extended with multiple options, which 
/// automatically add virtual functions, and hence create polymorphic behaviour
/// relevant to the client application.
///
/// In general, all the API functions that are being added to the interface (and described below)
/// use <a href="https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Non-Virtual_Interface">Non-Virtual Interface</a>
/// idiom:
/// @code
/// class MyMessage
/// {
/// public:
///     void someFunction(...)
///     {
///         ...; // Pre-conditions check and/or other common operations
///         someFunctionImpl(...); // Invocation of polymorphic functionality
///         ...; // Post-conditions check and/or other common operations
///     }
///
/// protected:
///     virtual void someFunctionImpl(...) = 0; // Must be implemented in the derived class
/// };
/// @endcode
/// The polymorphic behaviour is exposed via @b protected virtual functions having
/// the same name, but with @b Impl suffix.
///
/// All the variants of message interface class that are going to be described
/// below are descendants of @ref comms::Message class. Please refer to the
/// documentation of the latter for detailed info on the described functions and
/// their parameters.
///
/// @subsection page_use_prot_interface_id_retrieve Polymorphic Retrieval of Message ID
/// When there is a need to be able to polymorphically retrieve message ID,
/// the @ref comms::option::app::IdInfoInterface option needs to be used. Note, that this
/// option requires presence of @ref comms::option::def::MsgIdType (which is expected to
/// be used in protocol definition) to specify type
/// of the message ID in order to work properly.
/// @code
/// using MyMessage =
///     my_protocol::Message<
///         comms::option::app::IdInfoInterface,
///         ...
///     >;
/// @endcode
/// It adds the following functions:
/// @code
/// class MyMessage
/// {
/// public:
///     // API function to retrieve ID of the function
///     MsgIdParamType getId() const
///     {
///         return getIdImpl();
///     }
///
/// protected:
///     virtual MsgIdParamType getIdImpl() const = 0; // Automatically implemented in the actual message class
/// }
/// @endcode
/// The usage of @ref comms::option::app::IdInfoInterface without @ref comms::option::def::MsgIdType
/// will be ignored, and @b getId() as well as @b getIdImpl() member functions
/// won't be created.
///
/// The @ref comms::Message interface class defines @ref comms::Message::hasGetId()
/// static constexpr member function, which may be used at compile time to 
/// determine whether the @ref comms::option::app::IdInfoInterface option has been used, i.e. 
/// the message interface class defines mentioned earlier
/// functions.
///
/// @subsection page_use_prot_interface_read Polymorphic Read of Payload (Deserialisation)
/// If the implementation requires polymorphic read and process of input messages, the @b read()
/// operation needs to be added to the interface. It is achieved by using 
/// @ref comms::option::app::ReadIterator option to provide a type of the iterator that
/// is going to be used for reading:
/// @code
/// using MyMessage = 
///     my_protocol::Message<
///         ...
///         comms::option::app::ReadIterator<const std::uint8_t*>,
///         ...
///     >;
/// @endcode
/// As the result the interface class defines the following types and functions:
/// @code
/// class MyMessage
/// {
/// public:
///     // Type of the the iterator used for reading, the same as provided with
///     // comms::option::app::ReadIterator option.
///     typedef ... ReadIterator;
///
///     // API function to perform read
///     comms::ErrorStatus read(ReadIterator& iter, std::size_t len)
///     {
///         return readImpl(iter, len);
///     }
///
/// protected:
///     // Expected to be overriden in the derived class.
///     virtual comms::ErrorStatus readImpl(ReadIterator& iter, std::size_t len) 
///     {
///         return comms::ErrorStatus::NotSupported;
///     }
/// }
/// @endcode
/// Please @b note, that COMMS library doesn't impose any restrictions on
/// how the input data is collected and stored. It is a responsibility of the 
/// @b caller to allocate and maintain the input buffer, while providing only an 
/// iterator for read operation. @n
/// Also @b note, that iterator is passed by reference, which allows advancing 
/// operator when read operation is performed. @n
/// For example:
/// @code
/// std::size_t readMessage(MyMessage& msg, const std::uint8_t* buf, std::size_t len)
/// {
///     MyMessage::ReadIterator readIter = buf;
///     auto es = msg.read(readIter, len); // readIter is advanced in the read operation
///     if (es != comms::ErrorStatus::Success) {
///         ... // Report and handle error
///         return 0U; 
///     }
///     
///     // Report number of processed bytes from buffer:
///     auto bytesCount = std::distance(MyMessage::ReadIterator(buf), readIter);
///     return bytesCount;
/// }
/// @endcode
/// The @ref comms::Message interface class defines @ref comms::Message::hasRead()
/// static constexpr member function, which may be used at compile time to 
/// determine whether the @ref comms::option::app::ReadIterator option has been used, i.e. 
/// the message interface class defines mentioned earlier
/// types and functions.
///
/// @subsection page_use_prot_interface_write Polymorphic Write of Payload (Serialisation)
/// If the implementation requires polymorphic serialisation of the messages and sending them over I/O
/// link, the @b write() operation needs to be added to the interface. It is 
/// achieved by using @ref comms::option::app::WriteIterator option to provide a type of 
/// the iterator that is going to be used for writing:
/// @code
/// using MyMessage = 
///     my_protocol::Message<
///         ...
///         comms::option::app::WriteIterator<std::back_insert_iterator<std::vector<std::uint8_t> > >,
///         ...
///     >;
/// @endcode
/// As the result the interface class defines the following types and functions:
/// @code
/// class MyMessage
/// {
/// public:
///     // Type of the the iterator used for writing, the same as provided with
///     // comms::option::app::WriteIterator option.
///     typedef ... WriteIterator;
///
///     // API function to perform write
///     comms::ErrorStatus write(WriteIterator& iter, std::size_t len)
///     {
///         return writeImpl(iter, len);
///     }
///
/// protected:
///     // Expected to be overriden in the derived class.
///     virtual comms::ErrorStatus writeImpl(WriteIterator& iter, std::size_t len)
///     {
///         return comms::ErrorStatus::NotSupported;
///     }
/// }
/// @endcode
/// Please @b note, that COMMS library doesn't impose any restrictions on
/// storage type for the output buffer. It is a responsibility of the 
/// @b caller to allocate and maintain the output buffer, while providing only an 
/// iterator for write operation. In the example above the output buffer
/// is chosen to be @b std::vector<std::uint8_t> and the write operation will
/// be performed using @b push_back() calls on this vector (due to @b std::back_insert_iterator
/// being chosen as @b WriteIterator).
///
/// Also @b note, that iterator is passed by reference, which allows advancing 
/// operator when write operation is performed. In case the iterator is
/// random-access one, the difference between the initial and its value
/// after the write has been performed can be used to determine amount of 
/// bytes that have been written to the buffer.
///
/// The @ref comms::Message interface class defines @ref comms::Message::hasWrite()
/// static constexpr member function, which may be used at compile time to 
/// determine whether the @ref comms::option::app::WriteIterator option has been used, i.e. 
/// the message interface class defines mentioned earlier
/// types and functions.
///
/// @subsection page_use_prot_interface_length Polymorphic Serialisation Length Retrieval
/// Sometimes it may be needed to polymorphically retrieve the serialisation length of the message
/// in order to be able to reserve or allocate enough space for output buffer.
/// The @b COMMS library provides @ref comms::option::app::LengthInfoInterface option that
/// adds @b length() member function to the interface.
/// @code
/// using MyMessage = 
///     my_protocol::Message<
///         ...
///         comms::option::app::LengthInfoInterface,
///         ...
///     >;
/// @endcode
/// This option adds the following functions to the interface definition:
/// @code
/// class MyMessage
/// {
/// public:
///     // Retrieve the serialisation length
///     std::size_t length() const
///     {
///         return lengthImpl();
///     }
///
/// protected:
///     virtual std::size_t lengthImpl() const {...}; // Must be overridden in the derived class
/// };
/// @endcode
/// The @ref comms::Message interface class defines @ref comms::Message::hasLength()
/// static constexpr member function, which may be used at compile time to 
/// determine whether the @ref comms::option::app::LengthInfoInterface option has been used, i.e. 
/// the message interface class defines mentioned earlier
/// functions.
///
/// @subsection page_use_prot_interface_valid Polymorphic Validity Check
/// Sometimes it may be needed to be able to check whether the message contents
/// (fields) have valid values. The @b COMMS library provides comms::option::app::ValidCheckInterface
/// option that adds @b valid() member function to the interface:
/// @code
/// using MyMessage =
///     my_protocol::Message<
///         ...
///         comms::option::app::ValidCheckInterface,
///         ...
///     >;
/// @endcode
/// This option adds the following functions to the interface definition:
/// @code
/// class MyMessage
/// {
/// public:
///     // Retrieve the serialisation length
///     bool valid() const
///     {
///         return validImpl();
///     }
///
/// protected:
///     virtual bool validImpl() const
///     {
///         return true; // By default all messages are valid, can be overridden in derived class.
///     }
/// };
/// @endcode
/// The @ref comms::Message interface class defines @ref comms::Message::hasValid()
/// static constexpr member function, which may be used at compile time to 
/// determine whether the @ref comms::option::app::ValidCheckInterface option has been used, i.e. 
/// the message interface class defines mentioned earlier
/// functions.
///
/// @subsection page_use_prot_interface_handle Polymorphic Dispatch Message for Handling
/// When new data arrives on I/O link, it's transport framing is going to
/// be processed (described in detailed in @ref page_use_prot_transport section below).
/// and new message object is going to be created. It's going to be returned
/// as a smart pointer (std::unique_ptr) to the defined interface class (@b MyMessage).
/// The actual type of this message object needs to be recognised and message
/// properly handled. Using simple
/// switch statement on message ID (returned by @b getId() interface function)
/// can result in significant amount of boilerplate code, which grows and must
/// be updated every time new message is added to the protocol. 
/// The @b COMMS library provides much better way
/// to dispatch messages to appropriate handler. 
///
/// The handler class needs to be forward declared and passed
/// to the definition of @b MyMessage interface via @ref comms::option::app::Handler option.
/// @code
/// // Forward declaration
/// class MyHandler;
///
/// using MyHandler = 
///     my_protocol::Message<
///         ...
///         comms::option::app::Handler<MyHandler>,
///         ...
///     >;
/// @endcode
/// When this option is used the @b MyMessage will define the following interface
/// types and functions:
/// @code
/// class MyMessage
/// {
/// public:
///     // The same type as passed via comms::option::app::Handler option     
///     typedef ... Handler;
///
///     // Return type of the dispatch function, which is the same as return type of
///     // every Handler::handle() member function
///     typedef ... DispatchRetType;
///
///     // Dispatch this message to handler
///     DispatchRetType dispatch(Handler& handler)
///     {
///         return dispatchImpl(handler);
///     }
///
/// protected:
///     virtual DispatchRetType dispatchImpl(Handler& handler) {...} // Must be overridden in the derived class
/// };
/// @endcode
/// More details about polymorphic dispatching and handling will be provided 
/// below in @ref page_use_prot_handling section.
///
/// The @ref comms::Message interface class defines @ref comms::Message::hasDispatch()
/// static constexpr member function, which may be used at compile time to 
/// determine whether the @ref comms::option::app::Handler option has been used, i.e. 
/// the message interface class defines mentioned earlier
/// types and functions.
///
/// @subsection page_use_prot_interface_refresh Keeping Message Contents in a Consistent State
/// Some communication protocol may define fields that depend on other fields.
/// For example, bits in a bitmask field may be used to define whether some
/// optional fields exist. Or the information about amount of elements in 
/// the list to follow may reside in an independent numeric field. @n 
/// After updating such fields directly, using the interface of the message object,
/// the message contents may end up being in an inconsistent (or invalid) state.
/// There may be a need to polymorphically normalise the state of the message object. The
/// @b COMMS library provides @ref comms::option::app::RefreshInterface option, that adds
/// @b refresh() member function to the message interface.
/// @code
/// using MyMessage = 
///     comms::Message<
///         ...
///         comms::option::app::RefreshInterface,
///         ...
///     >;
/// @endcode
/// This option adds the following functions to the interface definition:
/// @code
/// class MyMessage
/// {
/// public:
///     // Refresh message contents
///     bool refresh()
///     {
///         return refreshImpl();
///     }
///
/// protected:
///     virtual bool refreshImpl()
///     {
///         return false;
///     }
/// };
/// @endcode
/// Note, that the @ref comms::Message::refresh() "refresh()" member function returns boolean value, which
/// is expected to be @b true in case at least one of the internal fields has
/// been updated, and @b false if message state remains unchanged. @n
/// Also note, that interface provide default implementation of @b refreshImpl()
/// virtual function. The message object that require proper "refresh" functionality
/// may just override it with proper implementation.
///
/// The @ref comms::Message interface class defines @ref comms::Message::hasRefresh()
/// static constexpr member function, which may be used at compile time to 
/// determine whether the @ref comms::option::app::RefreshInterface option has been used, i.e. 
/// the message interface class defines mentioned earlier
/// functions.
///
/// @subsection page_use_prot_interface_name Polymorphic Message Name Retrieval
/// Some applications may require knowledge about and report the name of the received / sent
/// message. The @b COMMS library provides @ref comms::option::app::NameInterface 
/// option, that adds @b name() member function to the message interface
/// (see @ref comms::Message::name()).
/// @code
/// using MyMessage = 
///     comms::Message<
///         ...
///         comms::option::app::NameInterface,
///         ...
///     >;
/// @endcode
/// This option adds the following functions to the interface definition:
/// @code
/// class MyMessage
/// {
/// public:
///     // Retrieve name of the message 
///     const char* name() const
///     {
///         return nameImpl();
///     }
///
/// protected:
///     virtual const char* nameImpl() const = 0; // Must be overridden in the derived class
/// };
/// @endcode
/// The @ref comms::Message interface class defines @ref comms::Message::hasName()
/// static constexpr member function, which may be used at compile time to 
/// determine whether the @ref comms::option::app::NameInterface option has been used, i.e. 
/// the message interface class defines mentioned earlier
/// functions.
///
/// @subsection page_use_prot_interface_virt_destructor Virtual Destructor
/// By default the @ref comms::Message class defines its 
/// destructor as @b virtual if and only if it exhibits a polymorphic behaviour, 
/// i.e. if there is at least one other virtual function defined. There are a couple of
/// ways to change this default behaviour.
/// @li If the definition of the common message interface class using 
///     exhibits polymorphic 
///     behaviour (i.e. has other virtual functions), but mustn't define its
///     destructor as @b virtual, use @ref comms::option::app::NoVirtualDestructor 
///     option in the interface class definition.
///     @code
///     using MyMessage = 
///         my_protocol::Message<
///             ...,
///             comms::option::app::NoVirtualDestructor
///         >;
///     @endcode
/// @li If the definition of the common interface class 
///     doesn't have any virtual function, but still requires an ability to 
///     be polymorphically deleted, i.e. must have virtual destructor, just 
///     inherit from @b my_protocol::Message and define the destructor as virtual.
///     @code
///     class MyMessage : public 
///         my_protocol::Message<>
///     {
///     public:
///         virtual ~MyMessage() = default;
///     };
///     @endcode
///
/// @subsection page_use_prot_interface_summary Interface Options Summary
/// All the options introduced above can be used in any order. They can also
/// be repeated multiple times. However, the option that was defined first takes
/// priority over (or overrides) the same option defined later. @n 
/// For example, the definition below defines @b WriteIterator to be
/// <b>std::uint8_t*</b>, because it was defined with first 
/// @ref comms::option::app::WriteIterator option:
/// @code
/// using MyMessage = 
///     my_protocol::Message<
///         ...
///         comms::option::app::WriteIterator<std::uint8_t*>, 
///         ...
///         comms::option::app::WriteIterator<std::back_insert_iterator<std::vector<std::uint8_t> >,
///         ...
///     >;
/// @endcode  
/// The definition below gives a full interface of all
/// the introduced functions: @b getId(), @b read(), @b write(), @b dispatch(),
/// @b length(), @b valid(), @b refresh(), and @b name().
/// @code
/// using MyMessage = my_protocol::Message<
///     comms::option::app::IdInfoInterface, // Add an ability to retrieve message ID value
///     comms::option::app::ReadIterator<const std::uint8_t*>, // Use const std::uint8_t* as iterator for reading
///     comms::option::app::WriteIterator<std::uint8_t*>, // Use std::uint8_t* as iterator for writing
///     comms::option::app::Handler<MyHandler>, // My MyHandler class declared earlier as a handler for messages
///     comms::option::app::LengthInfoInterface, // Add an ability to retrieve serialisation length
///     comms::option::app::ValidCheckInterface, // Add an ability to check contents validity
///     comms::option::app::RefreshInterface,  // Add an ability to refresh message contents
///     comms::option::app::NameInterface // Add an ability to retrieve message name
/// >;
/// @endcode
/// In case no polymorphic interface extension option has been chosen, every
/// message object becomes a simple "data structure" without any v-table "penalty".
/// @code
/// using MyInterface = my_protocol::Message<>;
/// @endcode
///
/// @section page_use_prot_messages Protocol Messages
/// The protocol messages are expected to be defined as template classes, receiving
/// at least one template parameter, which specifies the application specific interface 
/// class. For example
/// @code
/// namespace my_protocol
/// {
/// 
/// namespace message
/// {
///
/// template <typename TBase>
/// class Message1 : public
///     comms::MessageBase<
///         TBase,
///         ...
///     >
/// {
///     ...
/// };
///
/// } // namespace message
///
/// } // namespace my_protocol
/// @endcode
/// The interface class that was defined for the application (@b MyMessage) needs
/// to be passed as @b TBase template parameter. The defined message class 
/// extends @ref comms::MessageBase, which in turn extends provided interface
/// class @b TBase, which in turn extends (or typedef-s) @ref comms::Message. The inheritance
/// hierarchy may look like this:
/// @diafile message_class_hierarchy.dia
///
/// Due to the fact that every protocol message class extends @ref comms::MessageBase,
/// the detailed documentation on available member types and functions
/// can be viewed on @ref comms::MessageBase reference page.
///
/// All the protocol message classes implement @b non-virtual functions that may be
/// used to implement polymorphic behavior. These function has the same name as
/// described earlier interface, but start with @b do* prefix.
///
/// @li @b doRead() - implements message read functionality (see @ref comms::MessageBase::doRead())
/// @li @b doWrite() - implements message write functionality (see @ref comms::MessageBase::doWrite())
/// @li @b doLength() - implements message serialisation length calculation (see @ref comms::MessageBase::doLength())
/// @li @b doValid() - implements message contents validity check (see @ref comms::MessageBase::doValid())
/// @li @b doRefresh() - implements bringing message to a consistent state (see @ref comms::MessageBase::doRefresh())
/// @li @b doName() - implements retrieval of the message name.
///
/// Based on the requested polymorphic functionality, the @b comms::MessageBase
/// class automatically implements virtual @b *Impl() member functions (but only when needed).
/// @code
/// namespace my_protocol
/// {
/// 
/// namespace message
/// {
///
/// template <typename TBase>
/// class Message1 : public
///     comms::MessageBase<
///         TBase,
///         ...
///     >
/// {
/// public:
///     template <typename TIter>
///     comms::ErrorStatus doRead(TIter& iter, std::size_t len) {...}
///
///     template <typename TIter>
///     comms::ErrorStatus doWrite(TIter& iter, std::size_t len) const {...}
///
///     ...
/// protected:
///     virtual comms::ErrorStatus readImpl(ReadIterator& iter, std::size_t len)
///     {
///         return doRead(iter, len);
///     }
///
///     virtual comms::ErrorStatus writeImpl(WriteIterator& iter, std::size_t len) const
///     {
///         return doWrite(iter, len);
///     }
///
///     ...
/// };
///
/// } // namespace message
///
/// } // namespace my_protocol
/// @endcode
/// Such architecture allows usage of non-virtual functions when actual type
/// of the message is known. For example
/// @code
/// template <typename TMsg>
/// void writeMessage(const TMsg& msg)
/// {
///     auto es = msg.doWrite(...);
///     ...
/// }
/// @endcode
/// and using polymorphic behaviour when not
/// @code
/// void writeMessage(const MyMessage& msg)
/// {
///     static_assert(MyMessage::hasWrite(), "MyMessage must support polymorphic write");
///     auto es = msg.write(...);
///     ...
/// }
/// @endcode
/// Every message has zero or more fields, which are stored in @b std::tuple
/// as private members of @ref comms::MessageBase. The access to the fields
/// can be obtained using @b fields() member function (see @ref comms::MessageBase::fields()).
///
/// However, every message that has at least one field is expected to use
/// #COMMS_MSG_FIELDS_NAMES() (or #COMMS_MSG_FIELDS_ACCESS() in
/// older versions) macro to provide names to inner fields.
/// @code
/// namespace my_protocol
/// {
/// 
/// namespace message
/// {
///
/// template <typename TBase>
/// class Message1 : public
///     comms::MessageBase<
///         TBase,
///         ...
///     >
/// {
///     using Base = comms::MessageBase<...>;
///
/// public:
///     COMMS_MSG_FIELDS_NAMES(value1, value2, value3);
///     ...
/// };
///
/// } // namespace message
///
/// } // namespace my_protocol
/// @endcode
/// It is equivalent of having the following types and member functions defined.
/// @code
/// namespace my_protocol
/// {
/// 
/// namespace message
/// {
///
/// template <typename TBase>
/// class Message1 : public
///     comms::MessageBase<
///         TBase,
///         ...
///     >
/// {
/// public:
///     enum FieldIdx
///     {
///         FieldIdx_value1,
///         FieldIdx_value2,
///         FieldIdx_value3,
///         FieldIdx_numOfValues
///     }
///
///     // Access the "value1" field
///     auto field_value1() -> decltype(std::get<FieldIdx_value1>(fields()))
///     {
///         return std::get<FieldIdx_value1>(fields());
///     }
///
///     // Access the "value1" field (const variant)
///     auto field_value1() const -> decltype(std::get<FieldIdx_value1>(fields()))
///     {
///         return std::get<FieldIdx_value1>(fields());
///     }
///
///     // Access the "value2" field
///     auto field_value2() -> decltype(std::get<FieldIdx_value2>(fields()))
///     {
///         return std::get<FieldIdx_value2>(fields());
///     }
///
///     // Access the "value2" field (const variant)
///     auto field_value2() const -> decltype(std::get<FieldIdx_value2>(fields()))
///     {
///         return std::get<FieldIdx_value2>(fields());
///     }
///
///     // Access the "value3" field
///     auto field_value3() -> decltype(std::get<FieldIdx_value3>(fields()))
///     {
///         return std::get<FieldIdx_value3>(fields());
///     }
///
///     // Access the "value3" field (const variant)
///     auto field_value3() const -> decltype(std::get<FieldIdx_value3>(fields()))
///     {
///         return std::get<FieldIdx_value3>(fields());
///     }
///
///     // Types of used fields
///     using Field_value1 = ... /* implementation dependent field type */
///     using Field_value2 = ... /* implementation dependent field type */
///     using Field_value3 = ... /* implementation dependent field type */
/// };
///
/// } // namespace message
///
/// } // namespace my_protocol
/// @endcode
/// As the result every message field can be accessed by index
/// @code
/// using MyMessage1 = my_protocol::Message1<MyMessage>;
/// MyMessage1 msg;
/// auto& msg1Fields = msg.fields(); // access to std::tuple of message fields.
/// auto& value1Field = std::get<MyMessage1::FieldIdx_value1>(msg1Fields);
/// auto& value2Field = std::get<MyMessage1::FieldIdx_value2>(msg1Fields);
/// auto& value2Field = std::get<MyMessage1::FieldIdx_value2>(msg1Fields);
/// @endcode
/// or by name
/// @code
/// auto& value1Field = msg.field_value1();
/// auto& value2Field = msg.field_value2();
/// auto& value2Field = msg.field_value3();
/// @endcode
///
/// @section page_use_prot_fields Message Fields
/// In order to continue with the tutorial, it is paramount to understand a 
/// concept of @b fields, which are abstractions around value storage primitives and/or objects, 
/// such as integral values, floating point values, strings, arrays, etc..
/// Every @b field class is defined in @ref comms::field namespace and 
/// exposes predefined interface in order to
/// make template meta-programming as easy as possible. As an example let's
/// take a look at @ref comms::field::IntValue class which is used to 
/// define integral value field.
/// @code
/// template <typename TBase, typename T, typename... TOptions>
/// class comms::field::IntValue : public TBase
/// {
/// public:
///     // Define inner storage type
///     using ValueType = T;
///     
///     // Get access to the stored value
///     ValueType& value() { return m_value; }
///     const ValueType& value() const { return m_value; }
///
///     // Read
///     template <typename TIter>
///     comms::ErrorStatus read(TIter& iter, std::size_t len) {...}
///
///     // Write
///     template <typename TIter>
///     comms::ErrorStatus write(TIter& iter, std::size_t len) const {...}
///
///     // Serialisation length
///     std::size_t length() const {...}
///
///     // Validity of the value
///     bool valid() const {...}
///
///     // Bring field's contents into a consistent state
///     bool refresh() {...}
///
/// private:
///     ValueType m_value;
/// }
/// @endcode
/// The main things to note are that every field definition class:
/// @li receives its base class as the first 
///     template parameter. It is expected to be a variant of @ref
///     comms::Field with @ref comms::option::def::BigEndian or @ref 
///     comms::option::def::LittleEndian option to specify the serialisation endian.
///     It may be inner @b Field type of @b MyMessage interface class defined
///     earlier (@b MyMessage::Field - documented as @ref comms::Message::Field)
/// @li exhibits some default behaviour which can be modified by
///     passing various options from @ref comms::option::app and/or comms::option::def
///     namespaces as additional template
///     parameters. The options that define how field is serialised are expected
///     to be used as part of protocol definition. The protocol definition is
///     also expected to allow passing extra options that are relevant to application
///     environment and/or behaviour (such as modifying the default storage type).
/// @li defines @b ValueType inner value storage
///     type and provides @b value() member functions to access the stored value.
/// @li provides @b read() and @b write() member functions to read and write the 
///     inner value given the iterator used for reading / writing and available
///     length of the buffer.
/// @li has @b length() member function to report how many bytes are required to
///     serialise currently stored value.
/// @li provides @b valid() member function to check whether the stored value is
///     valid (within expected range of values).
/// @li has @b refresh() member function to bring its contents to consistent / valid
///     state when required.
///
/// Also note that all the member function are @b NON-virtual, i.e. the field 
/// abstractions do not have polymorphic behaviour.
///
/// The most important member function to a client application is @b value().
/// It allows access to the stored value. Note, that the stored value is accessed
/// by reference. It allows both get and set operations:
/// @code
/// auto myFieldValue = myField.value();
/// myField.value() = 5U;
/// @endcode
/// Other member functions are of lesser importance to the client application, 
/// they are used by the protocol definition itself to properly (de)serialise
/// message contents and provide other useful functionality.
///
/// The available fields abstractions are:
/// @li @ref comms::field::IntValue - used to define @ref page_use_prot_fields_int_value
/// @li @ref comms::field::EnumValue - used to define @ref page_use_prot_fields_enum_value
/// @li @ref comms::field::BitmaskValue - used to define @ref page_use_prot_fields_bitmask_value
/// @li @ref comms::field::Bitfield - used to define @ref page_use_prot_fields_bitfield
/// @li @ref comms::field::Bundle - used to define @ref page_use_prot_fields_bundle
/// @li @ref comms::field::ArrayList - used to define @ref page_use_prot_fields_array_list
/// @li @ref comms::field::String - used to define @ref page_use_prot_fields_string
/// @li @ref comms::field::FloatValue - used to define @ref page_use_prot_fields_fp_value
/// @li @ref comms::field::Optional - used to define @ref page_use_prot_fields_optional
/// @li @ref comms::field::Variant - used to define @ref page_use_prot_fields_variant
///
/// @subsection page_use_prot_fields_int_value Integral Value Fields
/// Integral value fields are defined using @ref comms::field::IntValue class.
/// Its inner @b ValueType type is the same as second template parameter. Most
/// integral value fields are defined and used "as-is"
/// @code
/// // base class for all the fields, usually defined by the protocol definition library
/// using MyFieldBase = comms::Field<comms::option::def::BigEndian>
///
/// // definition of integral field
/// using MyIntField = 
///     comms::field::IntValue<
///         MyFieldBase, // base class for all the fields, defined by the protocol definition library
///         std::uint16_t
///     >;
///
/// // usage of the field
/// MyIntField field;
/// field.value() = 5; // serialised as "00 05"
/// @endcode
/// Some field's definitions may use @ref comms::option::def::NumValueSerOffset
/// option, which adds predefined offset to the field before serialising and
/// subtracts it before deserialising. Classic example would be having a "year"
/// information, but serialised as offset from year @b 2000 with a single byte.
/// Such field may be defined as following:
/// @code
/// using YearField = 
///     comms::field::IntValue<
///         MyFieldBase, 
///         std::int16_t, 
///         comms::option::def::FixedLength<1>,
///         comms::option::def::NumValueSerOffset<-2000>
///     >;
/// @endcode
/// @b NOTE, that while serialisation takes only 1 byte, the client application
/// will use full year number without worrying about added / removed offset
/// @code
/// YearField field;
/// field.value() = 2018; // serialised as 0x12;
/// @endcode
/// Some protocols may exchange floating point values by serialising them as 
/// integral ones. For example, multiply the floating point value by 1000 before
/// the serialisation, and upon reception divide the received value by 1000 to 
/// get the floating point one. Such fields will be defined using @ref
/// comms::field::IntValue type with using @ref comms::option::def::ScalingRatio
/// option
/// @code
/// using MyFpField = 
///     comms::field::IntValue<
///         MyFieldBase, // base class for all the fields, defined by the protocol definition library
///         std::int32_t,
///         comms::option::def::ScalingRatio<1, 1000>
///     >;
/// @endcode
/// The inner value of such field is integral one. However, there are
/// @ref comms::field::IntValue::getScaled() and @ref comms::field::IntValue::setScaled()
/// member functions that allow get and set original floating point value without
/// worrying what math operation needs to be performed.
/// @code
/// MyFpField field;
/// field.setScaled(1.3f);
/// assert(field.value() == 1300); 
/// auto asDouble = field.getScaled<double>(); // equivalent to 1.3
/// @endcode
/// In addition to @b scaling, the @b COMMS library also provides an ability
/// to specify @b units. For example, some protocol may define distance in
/// @b 1/10 of the @b millimetres. The definition of such field may look like
/// this
/// @code
/// using MyDistance = 
///     comms::field::IntValue<
///         MyFieldBase,
///         std::int32_t,
///         comms::option::def::ScalingRatio<1, 10>,
///         comms::option::def::UnitsMillimeters         
/// @endcode
/// The @b COMMS library provides a @b limited set of units conversion functions in
/// @ref comms::units namespace. When using the provided conversion function the application developer
/// doesn't need to remember the original units and/or scaling factor. The @b COMMS library
/// does all the math. It also prevents (at compile time) usage of wrong conversion
/// functions, say calculating time (@b milliseconds), when specified units are 
/// @b distance (@b millimetres).
/// @code
/// MyDistance field; 
/// comms::units::setMeters(field, 1.2345);
/// std::cout << "Distance in 1/10 of mm:" << field.value() << std::endl; // prints 12345
/// std::cout << "Distance in mm" << comms::units::getMillimeters<double>(field); // prints 1234.5
/// std::cout << "Distance in cm" << comms::units::getCentimeters<double>(field); // prints 123.45
/// @endcode
/// @b NOTE, that @b COMMS library is about the communication protocols and not
/// about unit conversions. The unit conversion functionality is quite basic and
/// limited. If there is a need to use third party unit conversion library, it
/// could be wise to @b static_assert on assumption for origin units.
/// @code
/// static_assert(comms::units::isMillimeters<MyDistance>(), "Invalid units assumption");
/// @endcode
/// or
/// @code
/// static_assert(comms::units::isMillimeters(field), "Invalid units assumption");
/// @endcode
///
/// By default, When @ref comms::field::IntValue field is constructed, the inner
/// value is constructed to be 0. However, the field definition may use
/// @ref comms::option::def::DefaultNumValue option to specify some other value
/// @code
/// // definition of integral field
/// using MyIntField = 
///     comms::field::IntValue<
///         MyFieldBase, // base class for all the fields, defined by the protocol definition library
///         std::uint16_t,
///         comms::option::def::DefaultNumValue<25>
///     >;
///
/// MyIntField field;
/// assert(field.value() == 25);
/// @endcode
///
/// @subsection page_use_prot_fields_enum_value Enum Value Fields
/// The @b enum values are defined using @ref comms::field::EnumValue class. It
/// is very similar to @ref page_use_prot_fields_int_value. The main difference,
/// that second template parameter as well as inner @b ValueType type is @b enum.
/// The @b enum can be scoped (enum class) or regular (just enum).
/// @code
/// enum class SomeEnumVal : std::uint8_t
/// {
///     Val1,
///     Val2,
///     Val3,
///     NumOfValues
/// };
///
/// using SomeEnumField = 
///     comms::field::EnumValue<
///         MyFieldBase,
///         SomeEnumVal,
///         comms::option::def::ValidNumValueRange<0, (int)SomeEnumVal::NumOfValues - 1>,
///         comms::option::def::DefaultNumValue<(int)SomeEnumVal::Val3>
///     >;
///
/// SomeEnumField field;
/// assert(field.value() == SomeEnumVal::Val3); // initialised by default to Val3;
/// field.value() = SomeEnumVal::Val2;
/// @endcode 
/// Note, that underlying type of the enum dictates default serialisation length.
///
/// @subsection page_use_prot_fields_bitmask_value Bitmask Value Fields
/// Bitmasks (or bitsets) are also numeric values where every bit has separate,
/// independent meaning. Such fields are defined using @ref comms::field::BitmaskValue
/// class. 
/// @code
/// struct MyBitmask : public 
///     comms::field::BitmaskValue<
///         MyFieldBase, 
///         comms::option::def::FixedLength<1>,
///         comms::option::def::BitmaskReservedBits<0x2, 0> // Second bit is reserved and must be 0
///     >
/// {
///     ...
/// };
/// @endcode
/// The field definition will use @ref comms::option::def::FixedLength option in
/// order to specify its serialisation length. The inner @b ValueType type will
/// be calculated automatically and defined as one of the unsigned types: 
/// @b std::uint8_t, @b std::uint16_t, @b std::uint32_t, or @b std::uint64_t.
/// The usage of @ref comms::option::def::BitmaskReservedBits option will mark 
/// certain bits as "reserved". It influences only validity check functionality
/// (see @ref comms::field::BitmaskValue::valid()). If any of the reserved bits
/// doesn't have an expected value, the call to @b valid() member function will
/// return @b false.
///
/// The bitmask field definition is also expected to use #COMMS_BITMASK_BITS()
/// and #COMMS_BITMASK_BITS_ACCESS() macros to provide names for the bits
/// and generate convenience access function. If bit names are sequential, i.e. start
/// from bit @b 0, and go up without any holes in the middle, then single
/// #COMMS_BITMASK_BITS_SEQ() macro can be used instead achieving the same 
/// effect.
/// @code
/// struct MyBitmask : public
///     comms::field::BitmaskValue<
///         MyFieldBase, 
///         comms::option::def::FixedLength<1>,
///         comms::option::def::BitmaskReservedBits<0x2, 0> // Second bit is reserved and must be 0
///     >
/// {
///     COMMS_BITMASK_BITS(first, third=2, fourth, fifth, sixth, seventh, eighth);
///     COMMS_BITMASK_BITS_ACCESS(first, third, fourth, fifth, sixth, seventh, eighth);
/// }
/// @endcode
/// is equivalent to defining:
/// @code
/// struct MyBitmask : public
///     comms::field::BitmaskValue<
///         MyFieldBase, 
///         comms::option::def::FixedLength<1>,
///         comms::option::def::BitmaskReservedBits<0x2, 0> 
///     >
/// {
///     enum BitIdx 
///     {
///         BitIdx_first,
///         BitIdx_third=2,
///         BitIdx_fourth,
///         BitIdx_fifth,
///         BitIdx_sixth,
///         BitIdx_seventh,
///         BitIdx_eighth,
///         BitIdx_numOfValues
///     }
///
///     bool getBitValue_first() const { return getBitValue(BitIdx_first); }
///     void setBitValue_first(bool val) { setBitValue(BitIdx_first, val); }
///     bool getBitValue_third() const { ... }
///     void setBitValue_third(bool val) { ... }
///     bool getBitValue_fourth() const { ... }
///     void setBitValue_fourth(bool val) { ... }
///     ...
/// }
/// @endcode
/// The generated convenience access functions use existing 
/// @ref comms::field::BitmaskValue::getBitValue() and
/// @ref comms::field::BitmaskValue::setBitValue() member functions.
///
/// It is also possible to set multiple bits at the same time by accessing 
/// the stored value directly
/// @code
/// MyBitmask field;
/// field.value() = 0x81; // Setting first and eighth bits
/// @endcode
///
/// @subsection page_use_prot_fields_bitfield Bitfield Fields
/// Many communication protocols try to pack multiple independent values into
/// a one or several bytes to save traffic on I/O link. For example RS-232 serial port
/// configuration may be defined as following:
///
/// 3 Bits to configure baud rate:
/// |Baud Rate | Serialisation Value|
/// |:--------:|:------------------:|
/// | 9600     | 0                  |
/// | 14400    | 1                  |
/// | 19200    | 2                  |
/// | 28800    | 3                  |
/// | 38400    | 4                  |
/// | 57600    | 5                  |
/// | 115200   | 6                  |
///
/// 2 Bits to configure parity:
/// |Parity    | Serialisation Value|
/// |:--------:|:------------------:|
/// | None     | 0                  |
/// | Odd      | 1                  |
/// | Even     | 2                  |
///
/// 2 Bits to configure stopBits:
/// |Stop Bits     | Serialisation Value |
/// |:------------:|:-------------------:|
/// | One          | 0                   |
/// | One and half | 1                   |
/// | Two          | 2                   |
///
/// 2 Bits to configure flow control:
/// |Flow Control  | Serialisation Value |
/// |:------------:|:-------------------:|
/// | None         | 0                   |
/// | Hardware     | 1                   |
/// | Software     | 2                   |
///
/// The field definition will use @ref comms::field::Bitfield and probably look similar to code below
/// @code
/// enum class Baud {...}
/// enum class Parity {...}
/// enum class StopBits {...}
/// enum class FlowControl {...}
///
/// class SerialConfigField : public 
///     comms::field::Bitfield<
///         MyFieldBase, 
///         std::tuple<
///             comms::field::EnumValue<MyFieldBase, Baud, comms::option::def::FixedBitLength<3> >,
///             comms::field::EnumValue<MyFieldBase, Parity, comms::option::def::FixedBitLength<2> >,
///             comms::field::EnumValue<MyFieldBase, StopBits, comms::option::def::FixedBitLength<2> >,
///             comms::field::EnumValue<MyFieldBase, FlowControl, comms::option::def::FixedBitLength<2> >,
///             comms::field::IntValue<MyFieldBase, std::uint8_t, comms::option::def::FixedBitLength<7> >
///         >
///     >
/// {
///     // (Re)definition of the base class as inner Base type.
///     using Base = comms::field::Bitfield<...>;
/// public:
///     COMMS_FIELD_MEMBERS_NAMES(baud, parity, stopBits, flowControl, reserved);
/// }
/// @endcode
/// All the member fields of the @ref comms::field::Bitfield are stored internally 
/// as @b std::tuple, as the result the inner @b ValueType of such field is
/// @b std::tuple of all member fields and call to @ref comms::field::Bitfield::value()
/// member function will give an access to it. 
///
/// The field definition is expected to use @ref COMMS_FIELD_MEMBERS_NAMES() macro,
/// which will generate @b FieldIdx enum as well as convenience access member 
/// functions. The code becomes equivalent to:
/// @code
/// struct SerialConfigField : public 
///     comms::field::Bitfield<
///         MyFieldBase, 
///         std::tuple<
///             comms::field::EnumValue<MyFieldBase, Baud, comms::option::def::FixedBitLength<3> >,
///             comms::field::EnumValue<MyFieldBase, Parity, comms::option::def::FixedBitLength<2> >,
///             comms::field::EnumValue<MyFieldBase, StopBits, comms::option::def::FixedBitLength<2> >,
///             comms::field::EnumValue<MyFieldBase, FlowControl, comms::option::def::FixedBitLength<2> >,
///             comms::field::IntValue<MyFieldBase, std::uint8_t, comms::option::def::FixedBitLength<7> >
///         >
///     >
/// {
///     // Access indices for member fields
///     enum FieldIdx {
///         FieldIdx_baud,
///         FieldIdx_parity,
///         FieldIdx_stopBits,
///         FieldIdx_flowControl,
///         FieldIdx_reserved,
///         FieldIdx_numOfValues
///     };
/// 
///     // Accessor to "baud" field
///     auto field_baud() -> decltype(std::get<FieldIdx_baud>(value()))
///     {
///         return std::get<FieldIdx_baud>(value());
///     }
///
///     // Accessor to const "baud" field
///     auto field_baud() const -> decltype(std::get<FieldIdx_baud>(value()))
///     {
///         return std::get<FieldIdx_baud>(value());
///     }
///
///     // Accessor to "parity" field
///     auto field_parity() -> decltype(std::get<FieldIdx_parity>(value()))
///     {
///         return std::get<FieldIdx_parity>(value());
///     }
///
///     // Accessor to const "parity" field
///     auto field_parity() const -> decltype(std::get<FieldIdx_parity>(value()))
///     {
///         return std::get<FieldIdx_parity>(value());
///     }
///
///     ... // and so on for all other member fields
/// }
/// @endcode
/// Accessing the member field value in such setup, such as "baud" may look
/// like this:
/// @code
/// SerialConfigField configField;
/// configField.field_baud().value() = Baud::Val_115200;
/// @endcode
/// 
/// @subsection page_use_prot_fields_bundle Bundle Fields
/// There are cases when multiple independent fields need to be bundled into
/// a single field and expose the required interface of reading, writing,
/// calculating length, checking field's contents validity, and bringing field's
/// value into a consistent state. It may be required
/// when a message contains sequence (see @ref page_use_prot_fields_array_list) 
/// of such bundles/structs. The @b COMMS library provides @ref comms::field::Bundle
/// field for this purpose. It is quite similar to @ref comms::field::Bitfield described
/// earlier. The difference is that every member field
/// doesn't specify any length in bits, just bytes. For example:
/// @code
/// enum SomeEnum : std::uint8_t
/// {
///     SomeEnum_Value1,
///     SomeEnum_Value2,
///     SomeEnum_Value3,
///     ...
/// }
///
/// class MyBundle : public
///     comms::field::Bundle<
///         MyFieldBase,
///         std::tuple<
///             comms::field::IntValue<MyFieldBase, std::int16_t> // 2 bytes int value
///             comms::field::EnumValue<MyFieldBase, SomeEnum>, // 1 byte enum value
///             comms::field::BitmaskValue<MyFieldBase, comms::option::def::FixedLength<1> > // 1 byte bitmask
///         >
///     >
/// {
///     // (Re)definition of the base class as inner Base type.
///     using Base = comms::field::Bundle<...>;
/// public:
///     COMMS_FIELD_MEMBERS_NAMES(member1, member2, member3);
/// };
/// @endcode
/// Just like with @ref page_use_prot_fields_bitfield, the inner @b ValueType type
/// of such field is a @b std::tuple of member fields, and usage of 
/// @ref COMMS_FIELD_MEMBERS_NAMES() has exactly the same effect, i.e. generates
/// inner @b FieldIdx enum and convenience access member functions:
/// @code
/// struct MyBundle : public
///     comms::field::Bundle<
///         MyFieldBase,
///         std::tuple<
///             comms::field::IntValue<MyFieldBase, std::int16_t> // 2 bytes int value
///             comms::field::EnumValue<MyFieldBase, SomeEnum>, // 1 byte enum value
///             comms::field::BitmaskValue<MyFieldBase, comms::option::def::FixedLength<1> > // 1 byte bitmask
///         >
///     >
/// {
///     enum FieldIdx
///     {
///         FieldIdx_member1,
///         FieldIdx_member2,
///         FieldIdx_member3,
///         FieldIdx_numOfValues
///     };
///
///     // Accessor to "member1" field
///     auto field_member1() -> decltype(std::get<FieldIdx_member1>(value()))
///     {
///         return std::get<FieldIdx_member1>(value());
///     }
///
///     // Accessor to const "member1" field
///     auto field_member1() const -> decltype(std::get<FieldIdx_member1>(value()))
///     {
///         return std::get<FieldIdx_member1>(value());
///     }
///
///     // Accessor to "member2" field
///     auto field_member2() -> decltype(std::get<FieldIdx_member2>(value()))
///     {
///         return std::get<FieldIdx_member2>(value());
///     }
///
///     ...
/// };
/// @endcode
///
/// @subsection page_use_prot_fields_array_list Array List Fields
/// Some communication protocols may define messages that transmit sequence
/// of similar fields and/or raw data buffers. To make it easier to handle, the
/// @b COMMS library provides comms::field::ArrayList field which provide a required
/// interface to properly handle such sequences of data. It supports a
/// sequence of raw bytes
/// @code
/// using MySimpleList = 
///     comms::field::ArrayList<
///         MyFieldBase,
///         std::uint8_t // raw byte type as second template parameter
///     >;
/// @endcode
/// as well as using sequence of any fields defined in comms::field namespace
/// @code
/// using MyComplexList = 
///     comms::field::ArrayList<
///         MyFieldBase,
///         MyBundle // Complex bundle field, defined in previous section 
///     >;
/// @endcode
/// The @b default storage type (inner @b ValueType type) of these fields is
/// @b std::vector of specified type, i.e. it is @b std::vector<std::uint8_t>
/// in case of @b MySimpleList and @b std::vector<MyBundle> in case of
/// @b MyComplexList. Such default storage type may be unsuitable to certain
/// applications, especially for bare-metal ones. The @b COMMS library allows
/// changing it using extra options. The protocol definition is expected to
/// provide a way to pass extra options to such fields. It is explained in
/// @ref page_use_prot_fields_customisation section below in more details.
///
/// Please pay attention, that in case of non-raw data lists, the inner @b std::vector
/// contains fields, not values. As the result access to the stored values 
/// may require a bit of extra function calls:
/// @code
/// MyComplexList list;
/// auto& storageVec = list.value(); // access to std::vector<MyBundle>
/// storageVec.resize(1);
/// auto& firstBundle = storageVec[0]; // access to first MyBundle element
/// auto& firstMember1 = firstBundle.field_member1(); // access to "member1" member of first bundle
/// firstMember1.value() = ...; // assign the value of "member1"
/// @endcode
/// Some protocols may define fixed size lists. In such case lists are defined
/// with usage of @ref comms::option::def::SequenceFixedSize option. 
/// @code
/// using MyList = 
///     comms::field::ArrayList<
///         MyFieldBase,
///         comms::field::IntValue<MyFieldBase, std::uint16_t>,
///         comms::option::def::SequenceFixedSize<4>
///     >;
/// @endcode
/// Usage of this option just ensures right amount of elements "on the wire" after
/// the field is serialised, but it does @b NOT automatically resize inner 
/// storage vector.
/// @code
/// MyList field;
/// assert(field.value().empty()); // vector is empty upon construction
/// @endcode
///
/// @subsection page_use_prot_fields_string String Fields
/// Many protocols have to transfer strings. They are defined using
/// @ref comms::field::String field.
/// @code
/// using MyString = comms::field::String<MyFieldBase>;
/// @endcode
/// It is very similar to comms::field::ArrayList
/// it terms of value storage, read/write operations, and supported options.
/// By default the value is stored as 
/// <a href="http://en.cppreference.com/w/cpp/string/basic_string">std::string</a>.
/// @code
/// MyString myStr;
/// auto& myStrStorage = myStr.value(); // Reference to std::string.
/// @endcode
/// However, there are options that can modify this default behaviour. The
/// protocol definition classes are expected to provide a way to pass extra
/// application specific options to the string field definition. It is explained
/// in more details in @ref page_use_prot_fields_customisation section below.
///
/// Also similar to @ref page_use_prot_fields_array_list, fixed length strings
/// are defined using @ref comms::option::def::SequenceFixedSize option, and just
/// like with lists it does @b NOT automatically resize inner string, just ensures
/// right amount of characters "on the wire" when field is serialised.
/// @code
/// using MyFixedString = 
///     comms::field::String<
///         MyFieldBase,
///         comms::option::def::SequenceFixedSize<32>
///     >;
///
/// MyFixedString field;
/// assert(field.value().empty());
/// @endcode
///
/// @subsection page_use_prot_fields_fp_value Floating Point Value Fields
/// Floating point value fields are defined using @ref comms::field::FloatValue
/// They are very similar to 
/// @ref page_use_prot_fields_int_value, but use @b float or @b double as its 
/// internal storage type. They abstract the IEEE 754 floating point 
/// values, which are serialised "as is" with either big or little endian
/// encoding. The floating point value fields also support 
/// the same scaling and units conversion just like @ref page_use_prot_fields_int_value.
///
/// @subsection page_use_prot_fields_optional Optional Fields
/// Some protocols may define optional fields, which may exist or be missing
/// based on information recorded in other fields. For example there is a
/// "flags" bitmask field which specifies whether the following field exists or
/// missing. The optional field may also be tentative, i.e. if there is enough
/// data in the input buffer it exists, and missing otherwise. The @b COMMS
/// library provides @ref comms::field::Optional which is a mere wrapper around
/// other fields and provides an ability to set the optional state of the field.
/// @code
/// using OptField = 
///     comms::field::Optional<
///         comms::field::IntValue<MyFieldBase, std::int32_t>
///     >;
/// @endcode
/// The default mode of such field is "tentative", which means read if there
/// is data available in the input buffer, and write if there is enough space
/// in the output buffer.
/// @code
/// OptField field;
/// assert(field.isTentative());
/// @endcode
/// The default mode can be changed using @ref comms::option::def::ExistsByDefault
/// or @ref comms::option::def::MissingByDefault options. For example
/// @code
/// using ExistingOptField = 
///     comms::field::Optional<
///         comms::field::IntValue<MyFieldBase, std::int32_t>,
///         comms::option::def::ExistsByDefault
///     >;
///
/// ExistingOptField field;
/// assert(field.doesExist()); 
/// @endcode
/// @b NOTE, that inner @b ValueType of such field is wrapped actual field and
/// both @ref comms::field::Optional::value() and @ref comms::field::Optional::field()
/// member functions allow to access it. For example:
/// @code
/// OptField field;
/// auto& innerField = field.field(); // or call field.value()
/// innerField.value() = 1234;
/// field.setExists();
/// @endcode
///
/// @subsection page_use_prot_fields_variant Variant Fields
/// Some protocols may require usage of heterogeneous fields or lists of 
/// heterogeneous fields, i.e. the ones that can be of multiple types. Good example
/// would be a list of @b properties, where every property is a key/value pair
/// or a type/length/value triplet. The
/// key (or type) is usually a numeric ID of the property, while value can be 
/// any field of any length. Such fields are defined using 
/// @ref comms::field::Variant class. It is very similar to @ref 
/// page_use_prot_fields_bundle, but serves as one big union of provided member
/// fields, i.e. only one can be used at a time. 
///
/// As an example for the key/value pairs let's assume usage of three value types:
/// @li Unsigned integer with length of only 1 byte (@b Value1)
/// @li Unsigned integer with length of 4 bytes (@b Value2)
/// @li String field with 1 byte size prefix (@b Value3)
///
/// The @b COMMS library provides comms::field::Variant field to allow such
/// heterogeneous fields and the protocol definition may look something like
/// this:
/// @code
/// // Definition of value fields
/// using MyFieldBase = comms::Field<comms::option::def::BigEndian>;
/// using Value1 = comms::field::IntValue<MyFieldBase, std::uint8_t>;
/// using Value2 = comms::field::IntValue<MyFieldBase, std::uint32_t>;
/// using Value3 = 
///     comms::field::String<
///         MyFieldBase, 
///         comms::option::def::SequenceSizeFieldPrefix<
///             comms::field::IntValue<
///                 MyFieldBase,
///                 std::uint8_t
///             >
///         >
///     >;
/// 
/// //The common key type is usually represented as enum.
/// enum class KeyId : std::uint8_t
/// {
///     Key1,
///     Key2,
///     Key3,
///     NumOfValues
/// };
/// 
/// // Definition of "key" fields
/// template <KeyId TId>
/// using KeyField =
///     comms::field::EnumValue<
///         MyFieldBase,
///         KeyId,
///         comms::option::def::DefaultNumValue<(int)TId>,
///         comms::option::def::ValidNumValueRange<(int)TId, (int)TId>,
///         comms::option::def::FailOnInvalid<>
///     >;
/// 
/// using Key1 = KeyField<KeyId::Key1>;
/// using Key2 = KeyField<KeyId::Key2>;
/// using Key3 = KeyField<KeyId::Key3>;
/// 
/// // Definition of properties bundles
/// template <typename TKey, typename TValue>
/// class Property : public 
///     comms::field::Bundle<
///         MyFieldBase,
///         std::tuple<
///             TKey,
///             TValue
///         >
///     >
/// {
///     using Base = ...; // repeat base definition
/// public:
///     COMMS_FIELD_MEMBERS_NAMES(key, val);
/// };
///
/// using Property1 = Property<Key1, Value1>;
/// using Property2 = Property<Key2, Value2>;
/// using Property3 = Property<Key3, Value3>;
/// 
/// // Definition of the variant field
/// class MyVariant : public 
///     comms::field::Variant<
///         MyFieldBase,
///         std::tuple<Property1, Property2, Property3>
///     >
/// {
///     // (Re)definition of the base class as inner Base type.
///     using Base = comms::field::Variant<...>;
///
/// public:
///     COMMS_VARIANT_MEMBERS_NAMES(prop1, prop2, prop3);
/// };
/// 
///
/// // Definition of properties list
/// using PropertiesList = comms::field::ArrayList<MyFieldBase, MyVariant>;
/// @endcode
/// @b IMPORTANT: The @ref comms::field::Variant field uses uninitialized implementation
/// dependent storage area able to be initialized and hold any of the
/// provided member field types (but only one at a time). The inner 
/// @ref comms::field::Variant::ValueType "ValueType" type contains 
/// definition of the used storage type and 
/// @ref comms::field::Variant::value() "value()" member function which returns reference
/// to the used storage area. These type and function should @b NOT
/// be used directly. Instead, the  protocol definition is expected to 
/// use #COMMS_VARIANT_MEMBERS_NAMES() macro, which generates
/// appropriate access and conversion wrapper functions around
/// @ref comms::field::Variant::initField() and @ref comms::field::Variant::accessField().
///
/// The usage of #COMMS_VARIANT_MEMBERS_NAMES() in the above is
/// equivalent to having the following member types and functions defined
/// @code
/// struct MyVariant : public comms::field::Variant<...>
/// {
///     // Enumerator to access fields 
///     enum FieldIdx {
///         FieldIdx_prop1,
///         FieldIdx_prop2,
///         FieldIdx_prop3,
///         FieldIdx_numOfValues
///     }
///
///     // Initialize internal storage as "prop1"
///     template <typename... TArgs>
///     auto initField_prop1(TArgs&&... args) -> decltype(initField<FieldIdx_prop1>(std::forward<TArgs>(args)...))
///     {
///         return initField<FieldIdx_prop1>(std::forward<TArgs>(args)...)
///     }
///
///     // Access internal storage already initialized as "prop1"
///     auto accessField_prop1() -> decltype(accessField<FieldIdx_prop1>())
///     {
///         return accessField<FieldIdx_prop1>();
///     }
///
///     // Access internal storage already initialized as "prop1" (const variant)
///     auto accessField_prop1() const -> decltype(accessField<FieldIdx_prop1>())
///     {
///         return accessField<FieldIdx_prop1>();
///     }
///
///     // Initialize internal storage as "prop2"
///     template <typename... TArgs>
///     auto initField_prop2(TArgs&&... args) -> decltype(initField<FieldIdx_prop2>(std::forward<TArgs>(args)...))
///     {
///         return initField<FieldIdx_prop2>(std::forward<TArgs>(args)...)
///     }
///
///     // Access internal storage already initialized as "prop2"
///     auto accessField_prop2() -> decltype(accessField<FieldIdx_prop2>())
///     {
///         return accessField<FieldIdx_prop2>();
///     }
///
///     // Access internal storage already initialized as "prop2" (const variant)
///     auto accessField_prop2() const -> decltype(accessField<FieldIdx_prop2>())
///     {
///         return accessField<FieldIdx_prop2>();
///     }
///
///     // Initialize internal storage as "prop3"
///     template <typename... TArgs>
///     auto initField_prop3(TArgs&&... args) -> decltype(initField<FieldIdx_prop3>(std::forward<TArgs>(args)...))
///     {
///         return initField<FieldIdx_prop3>(std::forward<TArgs>(args)...)
///     }
///
///     // Access internal storage already initialized as "prop3"
///     auto accessField_prop3() -> decltype(accessField<FieldIdx_prop3>())
///     {
///         return accessField<FieldIdx_prop3>();
///     }
///
///     // Access internal storage already initialized as "prop3" (const variant)
///     auto accessField_prop3() const -> decltype(accessField<FieldIdx_prop3>())
///     {
///         return accessField<FieldIdx_prop3>();
///     }
///
///     // Types of used fields
///     using Field_prop1 = ... /* implementation dependent field type */
///     using Field_prop2 = ... /* implementation dependent field type */
///     using Field_prop3 = ... /* implementation dependent field type */
/// };
/// @endcode
/// @b NOTE, that the provided names have propagated into definition of @b FieldIdx
/// enum, all @b initField_* and @b accessField_* functions, as well as
/// inner @b Field_* types.
///
/// When variant field object is instantiated, 
/// accessing the currently held field can be tricky though. There is a need
/// to differentiate between @b compile-time and @b run-time knowledge of the
/// contents. 
///
/// When preparing a variant field (or message with variant fields) to be sent out, usually the inner 
/// field type and its value are known at compile time. The initialization of the
/// field can be performed using one of the @b initField_*() member
/// function described above:
/// @code
/// MyVariant var; // Created in "invalid" state
/// auto& prop1 = var.initField_prop1(); // Initialise as Property1 (constructor of prop1 is called)
/// auto& prop1ValField = prop1.field_val(); // Access the "value" field of the bundle
/// prop1ValField.value() = 0xff; // Update the property value
/// @endcode
/// or use @ref comms::field::Variant::initField() member function and generated
/// @b FieldIdx enum as compile time access index:
/// @code
/// auto& prop1 = var.initField<MyVariant::FieldIdx_prop1>();
/// @endcode
/// It is possible to re-initialize the field as something else, the previous
/// definition will be properly destructed.
/// @code
/// MyVariant var; // Created in "invalid" state
/// auto& prop1 = var.initField_prop1(); // Initialize as Property1 (constructor of prop1 is called)
/// auto& prop2 = var.initField_prop2(); // Destruct Property1 and initialize as Property2
/// @endcode
/// If the variant field has been initialized before, but there is a need to
/// access the real type (also known at compile time), use
/// appropriate @b accessField_*() member function:
/// @code
/// void updateProp1(MyVariant& var)
/// {
///     auto& prop1 = var.accessField_prop1(); // Access as Property1 (simple cast, no call to the constructor)
///     auto& prop1ValField = prop1.field_val()); // Access the "value" field of the bundle
///     prop1ValField.value() = 0xff; // Update the property value
/// }
/// @endcode
/// or use @ref comms::field::Variant::accessField() member function and generated
/// @b FieldIdx enum as compile time access index:
/// @code
/// auto& prop1 = var.accessField<MyVariant::FieldIdx_prop1>();
/// @endcode
/// There are cases (such as handling field after "read" operation), when actual type of the
/// @b Variant field is known at run-time. The most straightforward way is to
/// inquire the actual type index using comms::field::Variant::currentField()
/// function and then use a `switch` statement and handle every case accordingly.
/// @code
/// void handleMyVariant(const MyVariant& var)
/// {
///     switch(var.currentField())
///     {
///         case MyVariant::FieldIdx_prop1:
///         {
///             auto& prop1 = var.accessField_prop1(); // cast to "prop1"
///             ... // handle prop1;
///             break;
///         }
///         case MyVariant::FieldIdx_prop2:
///         {
///             auto& prop2 = var.accessField_prop2(); // cast to "prop2"
///             ... // handle prop2;
///             break;
///         }
///         ...
///     };
/// }
/// @endcode
/// However, such approach may require a significant amount of boilerplate code with 
/// manual (error-prone) "casting" to appropriate field type. 
/// The @b COMMS library provides a built-in way to perform relatively efficient (O(log(n))
/// way of dispatching the actual field to its appropriate handling function by
/// using comms::field::Variant::currentFieldExec() member function. It expects
/// to receive a handling object which can handle all of the available inner types:
/// @code
/// struct MyVariantHandler
/// {
///     template <std::size_t TIdx>
///     void operator()(Property1& prop) {...}
///
///     template <std::size_t TIdx>
///     void operator()(Property2& prop) {...}
///
///     template <std::size_t TIdx>
///     void operator()(Property3& prop) {...}
/// }
///
/// void handleVariant(MyVariant& var)
/// {
///     var.currentFieldExec(MyVariantHandler());
/// }
/// @endcode
/// @b NOTE, that every @b operator() function receives a compile time index
/// of the handed field within a containing tuple. If it's not needed when
/// handling the member field, just ignore it or static_assert on its value if
/// the index's value is known.
///
/// The class of the handling object may also receive the handled member type
/// as a template parameter
/// @code
/// struct MyVariantHandler
/// {
///     template <std::size_t TIdx, typename TField>
///     void operator()(TField& prop) {...}
/// }
/// @endcode
/// The example above covers basic key/value pairs type of properties. Quite
/// often protocols use TLV (type/length/value) triplets instead. Adding @b length
/// information allows having multiple @b value fields to follow (some of them may
/// be introduced in future versions of protocols) as well as receiving unknown
/// (to earlier versions of the protocol) properties and skipping over them. The
/// definition above may be slightly altered (see below) to support such
/// properties:
/// @code
/// ...
/// // No need for length prefix for string any more
/// using Value3 = comms::field::String<MyFieldBase>;
/// ...
/// // Definition of properties bundles
/// template <typename TKey, typename TValue>
/// class Property : public 
///     comms::field::Bundle<
///         MyFieldBase,
///         std::tuple<
///             TKey,
///             comms::field::IntValue<MyFieldBase, std::uint16_t>, // 2 byte value of remaining length
///             TValue
///         >,
///         comms::option::def::RemLengthMemberField<1> // Index of remaining length field is 1
///     >
/// {
///     using Base = ...; // repeat base definition
/// public:
///     COMMS_FIELD_MEMBERS_NAMES(key, length, val);
/// };
/// ...
/// @endcode
/// The rest of the handling code presented above applies for this kind as well
/// with one small nuance. The value of the @b length field depends on the
/// value of @b val (especially with variable length fields like strings).
/// 
/// When such property field is default constructed, the @b length is updated
/// to a correct value.
/// @code
/// MyVariant var;
/// auto& prop1 = var.initField_prop1(); // Initialize as Property1 (1 byte integral value)
/// assert(prop1.field_length().value() == 1U);
/// prop1.deinitField_prop1(); // Must be de-initialized before re-initialization as something else
/// auto& prop3 = var.initField_prop3(); // Re-initialize as Property3 (empty string)
/// assert(prop3.field_length().value() == 0U); // Remaining length of empty string
/// @endcode
/// In case the @b val field of the @b prop3 gets updated, the value of @b length
/// field is not valid any more. There is a need to bring it into a consistent state
/// by calling @b refresh() member function.
/// @code
/// prop3.field_val().value() = "hello";
/// prop3.refresh();
/// assert(prop3.field_length().value() == 5U);
/// @endcode
/// Note, that there is no need to call @b refresh() after every update of a variant
/// field. Usually such updates are done as preparation of the message to be sent. It
/// is sufficient to call @b doRefresh() member function of the message object at
/// the end of the update.
/// @code
/// SomeMessage msg;
/// auto& propsList = msg.field_propsList(); // access the properties list
/// auto& propsListVector = propsList.value(); // access the storage (vector);
/// propsListVector.resize(10); // create 10 properties (still invalid)
///
/// auto& prop1VariantField = propsListVector[0].initField_prop1(); // Initialize first as "prop1"
/// prop1VariantField.field_val().value() = 0xf;
///
/// auto& prop3VariantField = propsListVector[1].initField_prop3(); // Initialize second as "prop3"
/// prop3VariantField.field_val().value() = "hello";
///
/// ...
/// msg.doRefresh(); // Bring all fields into a consistent state in one go
/// @endcode
///
/// @subsection page_use_prot_fields_customisation Application Specific Customisation of Fields
/// The @b COMMS library provides multiple options to modify default behaviour
/// of field classes. Many of them modify the way how the field is (de)serialised.
/// Such options are expected to be used in actual protocol definition code. However,
/// there are also options that modify used data structures or field's behaviour. Such
/// options are application specific, and the protocol definition is expected
/// to provide a way on delivering such options to fields definitions. The recommended
/// way for the protocol definition is to have separate struct called @b DefaultOptions
/// which defines all the relevant extension options as its inner types. For example,
/// The message definition may look like this:
/// @code
/// #pragma once
/// #include "comms/comms.h"
///
/// #include "MyFieldBase.h" // Defines MyFieldBase common base class for all the fields
/// #include "DefaultOptions.h" // Defines DefaultOptions struct
///
/// namespace my_protocol
/// {
/// 
/// namespace message
/// {
///
/// template <typename TOpt = DefaultOptions>
/// struct Message1Fields
/// {
///     using field1 = ...;
///     using field2 = ...
///     using field3 = 
///         comms::field::String<
///             MyFieldBase,
///             typename TOpt::message::Message1Fields::field3 // Extra option(s) 
///         >
///
///     // bunding type
///     using All = 
///         std::tuple<
///             field1,
///             field2,
///             field3
///         >;
/// };
///
/// template <typename TBase, typename TOpt = DefaultOptions>
/// class Message1 : public 
///     comms::MessageBase<
///         TBase, 
///         comms::option::def::StaticNumIdImpl<MsgId_Message1>,
///         comms::option::def::FieldsImpl<Message1Fields<TOpt>::All>, // using fields with extra options
///         comms::option::def::MsgType<Message1<TBase, TOpt> > 
///     >
/// {
///     // (Re)definition of the base class
///     using Base = comms::MessageBase<...>; 
/// public:
///     // Provide names for the fields
///     COMMS_MSG_FIELDS_NAMES(value1, value2, value3);
/// };
///
/// } // namespace message
///
/// } // namespace my_protocol
/// @endcode
/// The inner structure of @b DefaultOptions struct is not important, but 
/// the recommended practice is to resemble the scope of fields. It may look 
/// like this
/// @code
/// namespace my_protocol
/// {
/// struct DefaultOptions
/// {
///     struct message
///     {
///         struct Message1Fields
///         {
///             using field1 = comms::option::app::EmptyOption; // no extra functionality by default
///             using field2 = comms::option::app::EmptyOption; // no extra functionality by default
///             using field3 = comms::option::app::EmptyOption; // no extra functionality by default
///         };
///     };
/// };
/// } // my_protocol
/// @endcode
/// The application is expected to provide its own options describing 
/// struct / class if needed. The easiest way is to extend provided @b DefaultOptions
/// and override selected types. For example
/// @code
/// struct MyOptions : public my_protocol::DefaultOptions
/// {
///     struct message : public my_protocol::DefaultOptions::message
///     {
///         struct Message1Fields : public my_protocol::DefaultOptions::message::Message1Fields
///         {
///             using field3 = comms::option::app::FixedSizeStorage<32>;
///         };
///     };
/// };
/// @endcode
/// The definition of the message(s) may look like this:
/// @code
/// using MyMessage1 = my_protocol::Message1<MyMessage, MyOptions>;
/// @endcode
/// If there is a need to pass more than one extra option to a field, these
/// options can be bundled together is @b std::tuple.
/// @code
/// struct MyOptions : public my_protocol::DefaultOptions
/// {
///     struct message : public my_protocol::DefaultOptions::message
///     {
///         struct Message1Fields : public my_protocol::DefaultOptions::message::Message1Fields
///         {
///             using field3 = std::tuple<..., ...>;
///         };
///     };
/// };
/// @endcode
///
/// @subsubsection page_use_prot_fields_customisation_seq Customisation for Lists and Strings
/// As was already mentioned earlier the default storage type (@b ValueType) of 
/// @ref page_use_prot_fields_array_list is @b std::vector, while default
/// storage type for @ref page_use_prot_fields_string is @b std::string. These
/// types are suitable for most of C++ applications, but may be unsuitable for
/// bare-metal embedded platforms. That why the protocol definition @b must allow
/// additional customisation of such fields. 
///
/// The @b COMMS library provides 
/// multiple options to change the default storage type. 
/// There is @ref comms::option::app::FixedSizeStorage option. When passed to the
/// @ref comms::field::ArrayList or @ref comms::field::String, it changes the
/// default storage type to be @ref comms::util::StaticVector or
/// @ref comms::util::StaticString respectively. These types expose the same
/// public API as @b std::vector or @b std::string, but use pre-allocated 
/// storage area (as their private member) to store the elements / characters.
/// Note, that the @ref comms::option::app::FixedSizeStorage option has a template
/// parameter, which specify number of elements (not necessarily bytes) to be
/// stored. If the field definition already uses @ref comms::option::def::SequenceFixedSize
/// option to specify that number of elements is fixed, there is 
/// @ref comms::option::app::SequenceFixedSizeUseFixedSizeStorage
/// option which has the same effect of forcing @ref comms::util::StaticVector
/// or @ref comms::util::StaticString to be storage types, but does not
/// require repeating specification of storage area size.
/// For example, if message type is defined to use provided @b DefaultOptions, then
/// the storage type of @b field3 will be @b std::string
/// @code
/// using MyMessage1 = my_protocol::Message1<MyMessage>;
/// MyMessage1 msg;
/// std::string& field3Str = msg.field_value3().value();
/// @endcode
/// However, if message type is defined to used described earlier @b MyOptions, then
/// the storage type of @b field3 will be @ref comms::util::StaticString
/// @code
/// using MyMessage1 = my_protocol::Message1<MyMessage, MyOptions>;
/// MyMessage1 msg;
/// comms::util::StaticString<32>& field3Str = msg.field_value3().value();
/// @endcode
/// NOTE, that using default @b std::vector / @b std::string or provided
/// @ref comms::util::StaticVector / @ref comms::util::StaticString will involve
/// copying of the data to these storage areas during the @b read operation. If
/// the input buffer is contiguous, i.e the pointer to the last element is @b always
/// greater than pointer to the first one (not some kind of circular buffer), then
/// copying of the data may be avoided by using @ref comms::option::app::OrigDataView
/// option. The option will change the default storage types to be 
/// <a href="https://en.cppreference.com/w/cpp/container/span">std::span&lt;std::uint8_t&gt;</a> or
/// <a href="https://en.cppreference.com/w/cpp/string/basic_string_view">std::string_view</a> respectively.
/// In case standard variants are unavalable due to used C++ standard or insufficient standard
/// library version then 
/// @ref comms::util::ArrayView and/or @ref comms::util::StringView will be used instead. 
///
/// @b NOTE, that
/// passing @ref comms::option::app::OrigDataView option to @ref comms::field::ArrayList
/// is possible only if it is list of raw data (@b std::uint8_t is used as element type).
/// @code
/// struct MyOptions : public my_protocol::DefaultOptions
/// {
///     struct message : public my_protocol::DefaultOptions::message
///     {
///         struct Message1Fields : public my_protocol::DefaultOptions::message::Message1Fields
///         {
///             using field3 = comms::option::app::OrigDataView;
///         };
///     };
/// };
/// @endcode
///
/// If default standard @b std::vector / @b std::string or all the provided 
/// by the @b COMMS library storage type are
/// not good enough, it is possible to specify custom storage type
/// using @ref comms::option::app::CustomStorageType option. For example:
/// @code
/// struct MyOptions : public my_protocol::DefaultOptions
/// {
///     struct message : public my_protocol::DefaultOptions::message
///     {
///         struct Message1Fields : public my_protocol::DefaultOptions::message::Message1Fields
///         {
///             using field3 = 
///                 comms::option::app::CustomStorageType<
///                     boost::container::pmr::string
///                 >;
///         };
///     };
/// };
/// @endcode
///
/// @subsubsection page_use_prot_fields_customisation_other Customisation for Other Fields
/// While allowing extra customisation for fields like @b list or @b string is
/// a <b>"must have"</b> feature of the protocol definition, it may also allow
/// additional customisation of other fields as well. For example, let's assume
/// that @b field1 of previously mentioned @b Message1 is a numeric field, that
/// defined the following way:
/// @code
/// #pragma once
/// #include "comms/comms.h"
///
/// #include "MyFieldBase.h" // Defines MyFieldBase common base class for all the fields
/// #include "DefaultOptions.h" // Defines DefaultOptions struct
///
/// namespace my_protocol
/// {
/// 
/// namespace message
/// {
///
/// template <typename TOpt = DefaultOptions>
/// struct Message1Fields
/// {
///     using field1 = 
///         comms::field::IntValue<
///             MyFieldBase,
///             std::uint8_t,
///             typename TOpt::message::Message1Fields::field1, // Extra options 
///             comms::option::def::DefaultNumValue<10>,
///             comms::option::def::ValidNumValueRange<10, 20>
///         >;
///     ...
/// };
///
/// template <typename TBase, typename TOpt = DefaultOptions>
/// class Message1 : public 
///     comms::MessageBase<
///         TBase, 
///         comms::option::def::StaticNumIdImpl<MsgId_Message1>,
///         comms::option::def::FieldsImpl<Message1Fields<TOpt>::All>, // using fields with extra options
///         comms::option::def::MsgType<Message1<TBase, TOpt> > 
///     >
/// {
///     ...
/// };
///
/// } // namespace message
///
/// } // namespace my_protocol
/// @endcode
/// If not other options are passed as @b message::Message1Fields::field1 inner
/// type of application specific options struct / class, then the inner value of 
/// @b field1 will be initialised to @b 10 upon construction and the range of
/// valid values will be <b>[10, 20]</b>. Such default settings may be modified
/// using various options. For example, making the value to be initialised to @b 5 and
/// adding it to valid values may look like this:
/// @code
/// struct MyOptions : public my_protocol::DefaultOptions
/// {
///     struct message : public my_protocol::DefaultOptions::message
///     {
///         struct Message1Fields : public my_protocol::DefaultOptions::message::Message1Fields
///         {
///             using field1 = 
///                 std::tuple<
///                     comms::option::def::DefaultNumValue<5>,
///                     comms::option::def::ValidNumValue<5>
///                 >;
///         };
///     };
/// };
/// @endcode
/// After these extra options are passed to the field's definition it becomes
/// equivalent to 
/// @code
///     using field1 = 
///         comms::field::IntValue<
///             MyFieldBase,
///             std::uint8_t,
///             comms::option::def::DefaultNumValue<5>, // overrides default value 10 defined below
///             comms::option::def::ValidNumValue<5>, // added to previously defined range [10, 20]
///             comms::option::def::DefaultNumValue<10>,
///             comms::option::def::ValidNumValueRange<10, 20>
///         >;
/// @endcode
/// @b NOTE that @b COMMS library processes all the options @b bottom-up, i.e.
/// starts with @b comms::option::def::ValidNumValueRange<10, 20> (which records initial
/// valid range [10, 20]), then processes @b comms::option::def::DefaultNumValue<10>
/// (which records default value to be 10), then processes @b comms::option::def::ValidNumValue<5>
/// (which @b adds value 5 to the existing valid ranges), then processes
/// @b comms::option::def::DefaultNumValue<5> (which changes the default value to be 5).
///
/// In case the application needs to override originally defined valid range(s) of
/// the field, it can use @ref comms::option::def::ValidRangesClear
/// option, which will clear all
/// previously defined valid ranges and will start accumulating them anew. For
/// example:
/// @code
/// struct MyOptions : public my_protocol::DefaultOptions
/// {
///     struct message : public my_protocol::DefaultOptions::message
///     {
///         struct Message1Fields : public my_protocol::DefaultOptions::message::Message1Fields
///         {
///             using field1 = 
///                 std::tuple<
///                     comms::option::def::DefaultNumValue<5>, // change the default value
///                     comms::option::def::ValidNumValue<5>, // add 5 to valid ranges of [40, 50]
///                     comms::option::def::ValidNumValueRange<40, 50>, // new range
///                     comms::option::def::ValidRangesClear // clear the default ranges
///                 >;
///         };
///     };
/// };
/// @endcode
/// Additional option that may be quite useful is @ref comms::option::def::FailOnInvalid.
/// It causes the @b read operation to fail with provided error status when
/// read value is not valid (@b valid() member function returns @b false).
///
/// There may be other useful options, which are not covered by this tutorial,
/// please open reference page of a required @b field class for the list of
/// supported options and read their documentation for more details.
///
/// @subsection page_use_prot_fields_value_assign Field Value Assignment
/// As was mentioned earlier, every field class has @b value() member function,
/// which provides an access to internal value storage. Quite often there
/// may be case when explicit cast is required.
/// @code
/// using MyField = comms::field::IntValue<FieldBase, std::uint8_t>; // One byte int
/// int someValue = ...;
/// MyField field;
/// field.value() = static_cast<std::uint8_t>(someValue);
/// @endcode
/// The code above is boilerplate one, which in general should be avoided, because in
/// case of the field definition being changed, the cast below must also be changed.
/// Such boilerplate code can be avoided by using extra compile time type manipulations:
/// @code
/// field.value() = static_cast<typename std::decay<decltype(field.value())>::type>(someValue);
/// @endcode
/// However, it's too much typing to do and quite inconvenient for the developer.
/// The @b COMMS library provides @ref comms::cast_assign() stand alone 
/// function which can be used for easy assignments with implicit @b static_cast to
/// appropriate type. It should be used for any arithmetic and/or enum storage
/// values.
/// @code
/// comms::cast_assign(field.value()) = someValue; // static_cast is automatic
/// @endcode
///
/// @subsection page_use_prot_fields_cast Cast Between Fields
/// There may also be cases when value of one field needs to be assigned to
/// value of another type. If @b static_cast between the values works, then
/// it is possible to use @ref comms::cast_assign() function described in 
/// @ref page_use_prot_fields_value_assign section above.
/// @code
/// comms::assign(field1.value()) = field2.value();
/// @endcode
/// However, there may be cases when such cast is not possible. For example
/// value of 1 byte @ref comms::field::IntValue needs to be assigned to 
/// a @ref comms::field::Bitfield length of which is also 1 byte, but it
/// splits the value into a couple of inner members. In this case 
/// the @ref comms::field_cast() function should be used.
/// @code
/// using MyInt = comms::field::IntValue<FieldBase, std::uint8_t>;
/// using MyBitfield = comms::field::Bitfield<...>;
/// MyInt field1;
/// MyBitfield field2;
/// ... // Set values of field1 and field2
/// field2 = comms::field_cast<MyBitfield>(field1);
/// @endcode
/// @b NOTE, that casting and assignment is performed on the field objects
/// themselves, not their stored values.
///
/// @section page_use_prot_transport Transport Framing
/// In addition to definition of the messages and their contents, every 
/// communication protocol must ensure that the message is successfully delivered 
/// over the I/O link to the other side. The serialised message payload must 
/// be wrapped in some kind of transport information prior to being sent and 
/// unwrapped on the other side when received. The @b COMMS protocol defines
/// multiple so called @b layers (defined in @b comms::frame namespace). 
/// The transport framing will be defined using those @b layer classes and may
/// be called @b Frame. Its definition is expected to
/// look something like this:
/// @code
/// namespace my_protocol
/// {
///
/// template <
///     typename TMessage, // common interface class defined by the application
///     typename TInputMessages = AllMessages<TMessage>, // Input messages that need to be recognised
///     typename TAllocationOptions = comms::option::app::EmptyOption // Extra options for comms::frame::MsgIdLayer
/// >
/// struct Frame : public 
///     MySyncPrefix<TMessage, TInputMessages, TAllocationOptions> 
/// {
///     COMMS_FRAME_LAYERS_ACCESS(...);
/// };
///
/// } // namespace my_protocol
/// @endcode
/// The first template parameter (@b TMessage) is common message interface class described
/// earlier in @ref page_use_prot_interface section.
/// 
/// The second template parameter (@b TInputMessages) is @b std::tuple of input
/// messages that @b read operation is expected to recognise. The message classes
/// must be sorted by the ascending order of message IDs. The protocol definition
/// is also expected to define @b AllMessages tuple which lists all the protocol
/// messages, which can be used as reference.
///
/// The third template parameter (@b TAllocationOptions) is extra option(s)
/// (bundled in @b std::tuple if more than one) to be passed to 
/// @ref comms::frame::MsgIdLayer class which is responsible for message
/// allocation. By default the message object is dynamically allocated, it is 
/// possible to modify such behaviour by using @ref comms::option::app::InPlaceAllocation
/// option. It will be explained in more details further below.
///
/// @b NOTE, that @b Frame definition is actually an alias to one
/// of the classes from @ref comms::frame namespace. To get a detailed
/// information on available public API please reference to one of them, for
/// example @ref comms::frame::SyncPrefixLayer.
///
/// It may also happen, that the extra options (@b TAllocationOptions)
/// are defined inside the recommended @b DefaultOptions structure and be
/// passed to the layers definitions themselves. Such approach is undertaken by
/// the **commsdsl2comms** code generator application from the 
/// <a href="https://github.com/commschamp/commsdsl">commsdsl</a> project.
/// @code
/// namespace my_protocol
/// {
///
/// struct DefaultOptions
/// {
///     ...
///     struct frame
///     {
///         // Extra options for Layers.
///         struct FrameLayers
///         {
///             // Extra options for Data layer.
///             using Data = comms::option::app::EmptyOption;
///             
///             // Extra options for Id layer.
///             using Id = comms::option::app::EmptyOption;
///             
///         }; // struct FrameLayers
///         
///     }; // struct frame
/// }/ // struct DefaultOptions
///
/// template <
///     typename TMessage, // common interface class defined by the application
///     typename TInputMessages = AllMessages<TMessage>, // Input messages that need to be recognised
///     typename TOpt = DefaultOptions // Options of the protocol definitions
/// >
/// struct Frame : public 
///     MySyncPrefix<TMessage, TInputMessages, TOpt> 
/// {
///     COMMS_FRAME_LAYERS_ACCESS(...);
/// };
///
/// } // namespace my_protocol
/// @endcode
///
/// @subsection page_use_prot_transport_read Reading Transport Framing and Message Payload
/// The @b COMMS library provides some convenience input processing and 
/// message dispatching functionality suitable for most cases. There is
/// @ref comms::processAllWithDispatch() function which is responsible to
/// process provided data in input buffer, detect and allocate message objects,
/// and dispatch them to provided handler. For example:
/// @code
/// #include "comms/process.h" // Contains processing function(s)
///
/// // Alias to my_protocol::Frame
/// using MyFrame = my_protocol::Frame<MyMessage>
///
/// MyFrame frame; // Frame object
/// MyHandler handler; // Handler object
/// std::size_t consumed = comms::processAllWithDispatch(buf, bufLen, frame, handler);
/// ... // Removed consumed bytes from input buffer
/// @endcode
/// The code above will dispatch allocated message objects to the provided
/// handler using @ref comms::dispatchMsg() function, which in turn performs 
/// compile time analysis of supported message types and can
/// result in either using polymorphic (see @ref comms::dispatchMsgPolymorphic()) or
/// static binary search (see @ref comms::dispatchMsgStaticBinSearch()) way
/// of dispatching. If such default behavior of the @b COMMS library is not
/// good enough for a particular application, it is recommended to use
/// @ref comms::processAllWithDispatchViaDispatcher() function instead, which
/// uses @ref comms::MsgDispatcher to force a particular way of dispatching.
/// @code
/// using MyDispatcher = comms::MsgDispatcher<comms::option::ForceDispatchStaticBinSearch>
/// std::size_t consumed = 
///     comms::processAllWithDispatchViaDispatcher<MyDispatcher>(buf, bufLen, frame, handler);
/// @endcode
/// If the described above processing functions (@ref comms::processAllWithDispatch() 
/// and @ref comms::processAllWithDispatchViaDispatcher()) are not good enough
/// for a particular application, there are several auxiliary functions that can
/// be used to implement application specific input data processing loop.
/// Please refer to the documentation of:
/// @li @ref comms::processSingleWithDispatch()
/// @li @ref comms::processSingleWithDispatchViaDispatcher()
/// @li @ref comms::processSingle()
///
/// There are protocols when number of input messages is very limited (one or two)
/// such as various types of acknowledgment. To support such case
/// @ref comms::frame::FrameLayerBase::read() "read()" member function of the
/// @b Frame as well as processing function(s) described above support reception of
/// reference to the real message object (instead of 
/// @ref comms::frame::FrameLayerBase::MsgPtr "MsgPtr" pointer).
/// @code
/// using MyAckMsg = my_protocol::AckMsg<MyMessage>;
/// MyAckMsg msg;
/// auto es = comms::processSingleWithDispatch(buf, bufLen, frame, msg);
/// if (es == comms::ErrorStatus::InvalidMsgId) {
///     // Unexpected message (not AckMsg) has been received, report or handle error
///     ...
/// }
/// @endcode
/// @b NOTE, that in such case there is @b no need for either @ref page_use_prot_interface_read
/// or @ref page_use_prot_interface_handle. In fact, no virtual function call
/// is used in the code above.
///
/// @subsection page_use_prot_transport_msg_alloc Message Object Allocation
/// By default, the message object is dynamically allocated. However, some 
/// applications (especially bare-metal ones) may require something different.
/// The @b COMMS library has @ref comms::option::app::InPlaceAllocation option, 
/// which may be passed as third template parameter (@b TAllocationOptions)
/// to @b Frame type definition. It statically allocates (in private data
/// members) storage area, that is capable to store any message object from
/// the @b std::tuple passed as second parameter to @b Frame type
/// definition. The message allocation is performed using "placement new" operator,
/// which means only one message object can be allocated at a time. The
/// smart pointer holding the message (@ref comms::frame::FrameLayerBase::MsgPtr "MsgPtr") is still
/// @b std::unique_ptr, but with custom deleter.
///
/// In case the @ref page_use_prot_interface "Message Interface" class does
/// not define any virtual function (which results in lack of virtual
/// destructor), the @b COMMS library also creates a custom deleter for
/// the defined smart pointer to the allocated message 
/// (see @ref comms::frame::FrameLayerBase::MsgPtr "MsgPtr") 
/// to allow proper downcast of the held pointer to the appropriate
/// class and invoke the correct destructor.
///
/// In such cases (that require usage of custom deleters) please refrain
/// from releasing the held object and/or changing the smart pointer type.
///
/// @subsection page_use_prot_transport_generic_msg Using Generic Message
/// In general, if message ID cannot be recognised, then appropriate message object cannot be
/// created and processed, i.e. the reading loop will just discard such input.
/// However, there are applications that serve as some kind of a @b bridge or
/// a @b firewall, i.e. need to recognise and process only limited 
/// number of input messages, all the rest need to be forwarded "as-is" or
/// maybe wrapped in different transport frame before sending it over
/// different I/O link. To help with such task @b COMMS library provides
/// @ref comms::GenericMessage class. There is also @ref comms::option::app::SupportGenericMessage
/// option that can be passed as third template parameter (@b TAllocationOptions)
/// to the @b Frame type definition. It will force of creation
/// @ref comms::GenericMessage object when appropriate message object is not found.
/// @code
/// // Define generic message type
/// using MyGenericMessage = comms::GenericMessage<MyMessage>;
///
/// // Limited number of supported messages
/// using MyInputMessages = 
///     std::tuple<
///         my_protocol::Message1<MyMessage>,
///         my_protocol::Message2<MyMessage>
///     >;
///
/// // Frame definition
/// using MyFrame = 
///     my_protocol::Frame<
///         MyMessage, 
///         MyInputMessages,
///         comms::option::app::SupportGenericMessage<MyGenericMessage>
///     >;
/// @endcode
/// @b NOTE, that @ref comms::GenericMessage has only single field, which
/// is a list of raw data (@ref comms::field::ArrayList). The @b read operation
/// of such field will result in copying the data from input buffer to 
/// internal storage of this field. The @ref comms::GenericMessage
/// class has also other template parameters (except common message interface class).
/// The second template parameter is option(s) that are going to be passed to this
/// comms::field::ArrayList field. If allocated message is @b not going to 
/// outlive input buffer, than it may make sense to pass @ref comms::option::app::OrigDataView
/// as second template parameter to @ref comms::GenericMessage.
/// @code
/// using MyGenericMessage = comms::GenericMessage<MyMessage, comms::option::app::OrigDataView>;
/// @endcode
///
/// Also @b note, that it is possible to combine usage of @ref comms::option::app::InPlaceAllocation
/// and @ref comms::option::app::SupportGenericMessage as the third template parameter to
/// @b Frame type definition using @b std::tuple bundling.
/// @code
/// using MyFrame = 
///     my_protocol::Frame<
///         MyMessage, 
///         MyInputMessages,
///         std::tuple<
///             comms::option::app::InPlaceAllocation,
///             comms::option::app::SupportGenericMessage<MyGenericMessage>
///         >
///     >;
/// @endcode
///
/// @subsection page_use_prot_transport_write Writing Transport Framing and Message Payload
/// The easiest way to implement write functionality is to use the ability of
/// the message object to perform polymorphic write.
/// @code
/// MyFrame frame; // Frame defined in one of previous sections
/// void sendMessage(const MyMessage& msg, std::uint8_t* buf, std::size_t len)
/// {
///     auto writeIter = comms::writeIteratorFor<MyMessage>(&buf[0]);
///     auto es = frame.write(msg, writeIter, len);
///     if (es == comms::ErrorStatus::Success) {
///         ... // Send contents of dataToSend via I/O link
///     }
/// }
/// @endcode
/// In order to support such polymorphic write the common message interface class
/// @b MyMessage has to have the following polymorphic functionality
///
/// @li @ref page_use_prot_interface_write to write the message payload.
/// @li @ref page_use_prot_interface_id_retrieve to write the message ID information.
///
/// In case the transport framing reports size that follows, the support for
/// @ref page_use_prot_interface_length is also recommended. It will be used
/// to write the required value right away. However, if not provided the dummy
/// value (@b 0) will be written at first, then after the write operation is complete,
/// the number of written bytes will be calculated and the previously written 
/// dummy value updated accordingly. @b NOTE, that such update is possible only
/// if iterator used for writing is random-access one. Otherwise, such update won't be
/// possible. In this case @ref comms::ErrorStatus::UpdateRequired error status
/// will be returned. It means that the write operation is incomplete, there
/// is a need to perform @b update() call with random-access iterator.
/// For example, let's assume the @ref page_use_prot_interface_length is
/// not supported and <b>std::back_insert_iterator\<std::vector\<std::uint8\> \></b>
/// is passed to @b MyMessage with @ref comms::option::app::WriteIterator option.
/// the message object to perform polymorphic write
/// @code
/// MyFrame frame; // Frame defined in one of previous sections
/// void sendMessage(const MyMessage& msg, std::vector<std::uint8_t>& outBuf)
/// {
///     assert(outBuf.empty()) // Make sure buffer is empty
///     auto writeIter = std::back_inserter(outBuf);
///     auto es = frame.write(msg, writeIter, outBuf.max_size());
///     if (es == comms::ErrorStatus::UpdateRequired) {
///         auto updateIter = &outBuf[0];
///         es = frame.update(updateIter, outBuf.size());
///     }
///         
///     if (es == comms::ErrorStatus::Success) {
///         ... // Send contents of dataToSend via I/O link
///     }
/// }
/// @endcode
/// Similar scenario of a need to handle @ref comms::ErrorStatus::UpdateRequired 
/// error status may occur when transport framing contains checksum value and
/// output (not random-access) iterator is used. The checksum calculation requires
/// going over the written data to calculate the value. However, it won't be 
/// possible to do right away, the @b update() call must follow.
///
/// There may be cases when @b update() operation also requires knowledge about
/// message object being written. For example when remaining size information
/// shares the same bytes with some extra flags, which can be retrieved from the message object being written.
/// To support such cases there is also overloaded 
/// @ref comms::frame::FrameLayerBase::update() "update()" member
/// function which also receives reference to message object/
/// @code
/// if (es == comms::ErrorStatus::UpdateRequired) {
///     auto updateIter = &outBuf[0];
///     es = frame.update(msg, updateIter, outBuf.size());
/// }
/// @endcode
///
/// The @b Frame does not require usage of polymorphic
/// write for message serialisation all the time. If number of messages being 
/// sent is not very high, sometimes it makes sense to avoid adding an ability
/// to support polymorphic write in the common interface. In this case the
/// sending functionality can be implemented using a template function where
/// actual message objects are passed as the parameter:
/// @code
/// template <typename TMsg>
/// void sendMessage(const TMsg& msg)
/// {
///     ...
///     auto es = frame.write(msg, ...);
///     ...
/// }
/// @endcode
/// Such implementation does not require any polymorphic behaviour from the
/// message object being sent, it takes all the required information from the
/// direct calls to non-virtual @b doGetId() (see @ref comms::MessageBase::doGetId()) and 
/// @b doLength() (see @ref comms::MessageBase::doLength()). The payload write is also performed using
/// direct call to @b doWrite() (see @ref comms::MessageBase::doWrite()).
///
/// @subsection page_use_prot_transport_caching Access to Processed Frame Fields
/// All the examples above do not store the read/written transport fields
/// anywhere. In most cases it is not needed. However, if need arises they can
/// be cached during the read/write operations and accessed later. The @b Frame
/// also defines @b AllFields type which is @b std::tuple of all the fields used by all the 
/// layer classes. @n
/// Also, the @b Frame defines 
/// @ref comms::frame::FrameLayerBase::readFieldsCached() "readFieldsCached()" 
/// and @ref comms::frame::FrameLayerBase::writeFieldsCached() "writeFieldsCached()"
/// member functions which are substitutes to normal 
/// @ref comms::frame::FrameLayerBase::read() "read()" and 
/// @ref comms::frame::FrameLayerBase::write() "write()". The first
/// parameter to these functions is reference to the 
/// @ref comms::frame::FrameLayerBase::AllFields "AllFields" bundle
/// object.
/// @code
/// MyFrame::AllFields fields;
/// auto es = frame.readFieldsCached(fields, msgPtr, readIter, bufSize);
/// @endcode
/// The layer class that is responsible to read/write payload data 
/// (see @ref comms::frame::MsgDataLayer) uses @ref comms::field::ArrayList
/// to define a field that will store the payload when "caching" operations are
/// performed. 
/// In case the the input / output buffer outlives the @b AllFields
/// object, consider passing @ref comms::option::app::OrigDataView option as the
/// fourth template parameter to @b Frame definition, which will pass it to
/// to the field containing the message payload raw data. Otherwise, the 
/// payload part from the read / written buffer will also be copied to storage
/// area of the cached payload field.
///
/// As was mentioned earlier, the frame is defined using so called
/// @b layer classes (defined in @ref comms::frame namespace) by wrapping
/// one another. Access to the appropriate layer may be obtained using a 
/// sequence of calls to @b nextLayer() member functions (see 
/// @ref comms::frame::FrameLayerBase::nextLayer()). Alternatively, the frame
/// definition is also expected to use #COMMS_FRAME_LAYERS_ACCESS()
/// macro to generate a convenience access functions. For example
/// @code
/// namespace my_protocol
/// {
///
/// template <
///     typename TMessage, // common interface class defined by the application
///     typename TInputMessages = AllMessages<TMessage>, // Input messages that need to be recognised
///     typename TAllocationOptions = comms::option::app::EmptyOption // Extra options for MsgIdLayer
/// >
/// struct Frame : public 
///     MySyncPrefix<TMessage, TInputMessages, TAllocationOptions> 
/// {
///     COMMS_FRAME_LAYERS_ACCESS(payload, id, size, checksum, sync);
/// };
///
/// } // namespace my_protocol
/// @endcode
/// The provided names are used in generation of access member functions with
/// @b layer_ prefix. The code above is equivalent to having the following 
/// member functions defined.
/// @code
/// template <
///     typename TMessage, // common interface class defined by the application
///     typename TInputMessages = AllMessages<TMessage>, // Input messages that need to be recognised
///     typename TAllocationOptions = comms::option::app::EmptyOption // Extra options for MsgIdLayer
/// >
/// struct Frame : public 
///     MySyncPrefix<TMessage, TInputMessages, TAllocationOptions> 
/// {
///     // Access to PAYLOAD layer
///     decltype(auto) layer_payload();
///
///     // Const access to PAYLOAD layer
///     decltype(auto) layer_payload() const;
///
///     // Access to ID layer
///     decltype(auto) layer_id();
///
///     // Const access to ID layer
///     decltype(auto) layer_id() const;
///
///     // Access to SIZE layer
///     decltype(auto) layer_size();
///
///     // Const access to SIZE layer
///     decltype(auto) layer_size() const;
///
///     // Access to CHECKSUM layer
///     decltype(auto) layer_checksum();
///
///     // Const access to CHECKSUM layer
///     decltype(auto) layer_checksum() const;
///
///     // Access to SYNC layer
///     decltype(auto) layer_sync();
///
///     // Const access to SYNC layer
///     decltype(auto) layer_sync() const;
/// };
/// @endcode
/// Then the access to the appropriate layer as as simple as calling appropriate
/// @b layer_*() member function. Once the access is obtained, it is possible to
/// call @b accessCachedField() (see @ref comms::frame::FrameLayerBase::accessCachedField())
/// member function to get an access to appropriate field. For example:
/// @code
/// MyFrame frame; // Frame object
/// MyFrame::AllFields fields; // Transport fields
/// auto es = frame.readFieldsCached(fields, msgPtr, readIter, bufSize);
/// if (es != comms::ErrorStatus::Success) {
///     ... // handle error
///     return;
/// }
/// std::cout << "SYNC = " << frame.layer_sync().accessCachedField(fields).value() << '\n';
/// std::cout << "SIZE = " << frame.layer_size().accessCachedField(fields).value() << '\n';
/// std::cout << "ID = " << frame.layer_id().accessCachedField(fields).value() << '\n';
/// std::cout << "CHECKSUM = " << frame.layer_checksum().accessCachedField(fields).value() << std::endl;
/// @endcode
/// Version @b v2.0 the @b COMMS library has introduced additional way to retrieve 
/// values from stripped message framing. There are several functions listed
/// below that can be used to pass extra variadic arguments to the "read" functions
/// of the frame (see @ref comms::frame::FrameLayerBase::read() "read()"
/// and @ref comms::frame::FrameLayerBase::readFieldsCached "readFieldsCached()").
/// @li @ref comms::frame::missingSize() - Use to retrieve minimal missing
/// size required to be read in order the following "read()" operation to have
/// a chance of being completed successfully.
/// @li @ref comms::frame::msgId() - Use to retrieve numeric message ID.
/// @li @ref comms::frame::msgIndex() - Use to retrieve index of the message
/// among difference message types that have the same numeric ID.
/// @li @ref comms::frame::msgPayload() - Use to retrieve the location 
/// of message payload in the input buffer.
/// 
/// For example there can be a case when @ref page_use_prot_interface
/// does not support @ref page_use_prot_interface_handle. In this case 
/// it might be required to retrieve the information about message ID and
/// its relevant index in order to dispatch message object to its
/// appropriate handling function (see @ref page_dispatch).
/// @code
/// // Alias to my_protocol::Frame
/// using MyFrame = my_protocol::Frame<MyMessage>
///
/// MyFrame frame; // Frame object
/// MyHandler handler; // Handler object
/// MyFrame::MsgPtr msg; Pointer to message to be updated
/// my_protocol::MsgId msgId = my_protocol::MsgId(); // Message ID to be updated 
/// std::size_t msgIndex = 0U; // Message index to be updated
///
/// auto es = 
///     frame.read(
///         msg, 
///         readIter, 
///         bufLen, 
///         comms::frame::msgId(msgId), // msgId will be updated here
///         comms::frame::msgIndex(msgIndex)); // msgIndex will be updated here
/// if (es == comms::ErrorStatus::Success) {
///     assert(msg); // Message object is expected to be valid
///
///     // Dispatch message knowing its id and index.
///     comms::dispatchMsg<MyInputMessages>(msgId, msgIndex, *msg, handler);
/// }
/// @endcode 
///
/// @section page_use_prot_handling Message Handling
/// When a message is received over I/O link and successfully deserialised, it 
/// needs to be dispatched to appropriate handling function. Many
/// developers write quite big (depends on number of messages it needs to handle) 
/// switch statement that checks the ID of the message and calls appropriate 
/// function in the relevant case area. Other developers try to minimise 
/// amount of boilerplate code by introducing hand written map from message ID to the 
/// handling function. Such approaches may be quite inefficient in terms of 
/// execution performance as well as development effort required to introduce 
/// a new message when protocol evolves.
///
/// The @b COMMS library has a built-in efficient (O(1)) dispatch mechanism, which
/// uses "Double Dispatch" idiom. The @ref page_use_prot_interface_handle
/// section above described using @b comms::option::app::Handler option, which
/// adds polymorphic @b dispatch() member function to the common interface class
/// (@b MyMessage). The provided handling class (@b MyHandler) is expected
/// to define @b handle() member function for every message class it is expected to
/// handle.
/// @code
/// class MyHandler
/// {
/// public:
///     void handle(my_protocol::Message1<MyMessage>& msg) {...}
///     void handle(my_protocol::Message5<MyMessage>& msg) {...}
///     ...
/// }
/// @endcode
/// and a single @b handle() member function that receives common message
/// interface class for all the messages that need to be ignored or handled
/// in some other common way. If this function is not added, the compilation
/// may fail.
/// @code
/// class MyHandler
/// {
/// public:
///     ...
///     void handle(MyMessage& msg) {} // do nothing for all other messages
/// }
/// @endcode
/// For example, let's assume that @b MyHandler defines message to properly
/// handle @b Message1, but doesn't care about @b Message2. In this case
/// @code
/// std::unique_ptr<MyMessage> msg1(new my_protocol::Message1<MyMessage>);
/// std::unique_ptr<MyMessage> msg2(new my_protocol::Message2<MyMessage>);
/// MyHandler handler;
///
/// msg1->dispatch(handler); // invokes handle(my_protocol::Message1<MyMessage>&)
/// msg2->dispatch(handler); // invokes handle(MyMessage&)
/// @endcode
///
/// @b NOTE, that @b MyMessage class is only forward declared when 
/// @ref page_use_prot_interface (@b MyMessage), but needs to be properly
/// defined (included if in separate file) when defining @ref page_use_prot_transport.
///
/// @subsection page_use_prot_handling_multi Having Multiple Handlers
/// There may be a need for being able to dispatch message for multiple independent handlers. 
/// Good example would be having a state-machine, where every state processes
/// the same message in different way. It is simple to implement by just
/// defining the handling functions as @b virtual.
/// @code
/// class MyHandler
/// {
/// public:
///     virtual void handle(my_protocol::Message1<MyMessage>& msg) = 0;
///     virtual void handle(my_protocol::Message2<MyMessage>& msg) = 0;
///     virtual void handle(my_protocol::Message3<MyMessage>& msg) = 0;
///     ...
/// };
/// @endcode
/// Defining the concrete handlers:
/// @code
/// class Handler1 : public MyHandler
/// {
/// public:
///     virtual void handle(my_protocol::Message1<MyMessage>& msg) override {...};
///     virtual void handle(my_protocol::Message2<MyMessage>& msg) override {...};
///     virtual void handle(my_protocol::Message3<MyMessage>& msg) override {...};
///     ...
/// };
///
/// class Handler2 : public MyHandler
/// {
/// public:
///     virtual void handle(my_protocol::Message1<MyMessage>& msg) override {...};
///     virtual void handle(my_protocol::Message2<MyMessage>& msg) override {...};
///     virtual void handle(my_protocol::Message3<MyMessage>& msg) override {...};
///     ...
/// };
/// @endcode
/// Now, any of the handlers may be used to handle the message:
/// @code
/// std::unique_ptr<MyMessage> msg(.../* some message object */);
/// Handler1 handler1;
/// Handler2 handler2;
///
/// msg->dispatch(handler1); // Handle with handler1
/// msg->dispatch(handler2); // Handle with handler2
/// @endcode
///
/// @subsection page_use_prot_handling_generic Generic Handler
/// The @b COMMS library provides some help in defining custom message handlers.
/// There is @ref comms::GenericHandler class that receives at least two template
/// parameters. The first one is a common interface class for all the handled messages
/// (@b MyMessage). The second template parameter is
/// all the types of all the custom messages the handler is supposed to handle,
/// bundled into std::tuple. Remember defining a bundle of messages (@b MyInputMessages) that need
/// to be recognised during @ref page_use_prot_transport_read? It's probably
/// a good place to reuse it or define a new tuple if there is a mismatch.
/// @code
/// using MyMessagesToHandle = MyInputMessages;
/// @endcode
/// As the result the comms::GenericHandler implements @b virtual @b handle()
/// function for all the provided messages including the provided interface one.
/// The code that automatically generated by @b comms::GenericMessage is equivalent
/// to the one below.
/// @code
/// template<>
/// class GenericHandler<MyMessage, MyMessagesToHandle>
/// {
/// public:
///     virtual void handle(MyMessage& msg) {} // Do nothing
///
///     virtual void handle(my_protocol::Message1<MyMessage>& msg)
///     {
///         this->handle(static_cast<MyMessage&>(msg)); // invoke default handling
///     }
///
///     virtual void handle(my_protocol::Message2<MyMessage>& msg)
///     {
///         this->handle(static_cast<MyMessage&>(msg)); // invoke default handling
///     }
///
///     ...
/// };
/// @endcode
/// Now, what remains is to inherit from comms::GenericHandler and override
/// the functions that need to be overridden:
/// @code
/// class MyHandler : public comms::GenericHandler<MyMessage, AllMessages>
/// {
/// public:
///     // Enable polymorphic delete
///     virtual ~MyHandler() {}
///
///     // Overriding the default handling function
///     virtual handle(MyMessage& msg) override
///     {
///         std::cout << "Ignoring message with ID: " << msg.getId() << std::endl;
///     }
///
///     // Overriding handling of Message1
///     virtual handle(my_protocol::Message1<MyMessage>& msg) override
///     {
///         ...; // Handle Message1
///     }
/// };
/// @endcode
/// Pay attention that @ref comms::GenericHandler doesn't declare its destructor as virtual.
/// If the handler object requires support for polymorphic delete (destruction),
/// make sure to declare its destructor as virtual.
///
/// @subsection page_use_prot_handling_result Returning Handling Result
/// All the examples above used @b void as a return type from handling functions. It
/// is possible, however, to return value of handling result. In order to achieve
/// this the handler class needs to define inner @b RetType type and all the
/// @b handle() functions must return it. For example:
/// @code
/// class MyHandler
/// {
/// public:
///     // Return type of all the handle() functions
///     typedef bool RetType;
///
///     bool handle(my_protocol::Message1<MyMessage>& msg) {...}
///     bool handle(my_protocol::Message2<MyMessage>& msg) {...}
///     bool handle(my_protocol::Message3<MyMessage>& msg) {...}
///     ...
/// };
/// @endcode
/// If inner @b RetType type is defined, it is propagated to be also the return type of
/// the @ref comms::Message::dispatch() member function as well. As the result the developer may 
/// use constructs like this:
/// @code
/// bool result = msg->dispatch(handler);
/// @endcode
///
/// If @ref comms::GenericHandler class is used to define the handler class, its
/// third template parameter (which defaults to @b void), can be used to
/// specify the return type of handling functions.
///
/// @b NOTE, since version @b v1.1 the @b COMMS library supports other
/// ways to dispatch a message object to its handling function in addition
/// to one described above. Please read @ref page_dispatch page for more details.
///
/// @section page_use_prot_extra_transport Extra Transport Values
/// Some protocols may use extra values in their transport information, which 
/// may influence the way how message payload is being read and/or message 
/// object being handled. Good example would be having a protocol version, 
/// which defines what message payload fields were serialised and which were 
/// not (because they were introduced in later version of the protocol). 
/// Such extra information is stored in the message object itself. If this is
/// the case, the protocol definition is expected to use 
/// @ref comms::option::def::ExtraTransportFields option in addition to specifying
/// serialisation endian and message ID type (described in @ref
/// page_use_prot_interface).
/// (see @ref page_field_tutorial) and bundled in @b std::tuple:
/// @code
/// namespace my_protocol
/// {
/// 
/// // Field describing protocol version.
/// using MyVersionField = 
///     comms::field::IntValue<
///         MyFieldBase, 
///         std::uint16_t,
///         comms::option::def::DefaultNumValue<5> // Implementing v5 of the protocol by default
///     >;
///
/// // Relevant extra transport fields, bundled in std::tuple
/// using MyExtraTransportFields =
///     std::tuple<
///         MyVersionField
///     >;
///
/// template <typename... TOptions>
/// class Message : public
///     comms::Message<
///         comms::option::def::BigEndian,
///         comms::option::def::MsgIdType<MsgId>,
///         comms::option::def::ExtraTransportFields<MyExtraTransportFields>,
///         TOptions...
///     >
/// {
///     // (Re)definition of the base class as inner Base type
///     using Base = comms::Message<...>;
/// public:
///     COMMS_MSG_TRANSPORT_FIELDS_NAMES(version)
/// };
///
/// } // namespace my_protocol
/// @endcode
/// Usage of @ref comms::option::def::ExtraTransportFields option as well as
/// #COMMS_MSG_TRANSPORT_FIELDS_NAMES() macro in the message class definition
/// is equivalent to having the following types and member functions defined
/// @code
/// namespace my_protocol
/// {
/// 
/// template <typename... TOptions>
/// class Message : public
///     comms::Message<
///         comms::option::def::BigEndian,
///         comms::option::def::MsgIdType<MsgId>,
///         TOptions...
///     >
/// {
/// public:
///     // Type of extra fields
///     using TransportFields = MyExtraTransportFields;
///
///     // Accessors for defined transport fields
///     TransportFields& transportFields() { return m_transportFields; }
///     const TransportFields& transportFields() const { return m_transportFields; }
///
///     // Indices to access extra transport fields
///     enum TransportFieldIdx
///     {
///         TransportFieldIdx_version,
///         TransportFieldIdx_numOfValues
///     };
///
///     // Access the "version" extra transport field
///     auto transportField_version() -> decltype(std::get<TransportFieldIdx_version>(transportFields()))
///     {
///         return std::get<TransportFieldIdx_version>(transportFields());
///     }
///
///     // Access the "version" extra transport field (const version)
///     auto transportField_version() const -> decltype(std::get<TransportFieldIdx_version>(transportFields()))
///     {
///         return std::get<TransportFieldIdx_version>(transportFields());
///     }
///
///     // Definition of the transport field's types
///     using TransportField_version = MyVersionField;
///
/// private:
///     TransportFields m_transportFields;
/// };
///
/// } // namespace my_protocol
/// @endcode
/// For reference see also description of @ref comms::Message::transportFields()
/// member function.
///
/// Access to the version information given a reference to message object may
/// now be implemented as:
/// @code
/// void handle(my_protocol::Message<>& msg)
/// {
///     // Retrieve the version numeric value
///     auto versionValue = msg.transportField_version().value();
///
///     ... // do something with version information
/// }
/// @endcode
/// @b NOTE, that the defined "extra transport fields" are there to attach 
/// some extra information, delivered as part of transport framing, to message 
/// object itself. These fields are @b NOT getting serialised / deserialised when message
/// object (payload) being read / written.
///
/// The @ref comms::Message interface class defines @ref comms::Message::hasTransportFields()
/// static constexpr member function, which may be used at compile time to 
/// determine whether the @ref comms::option::def::ExtraTransportFields option has been used, i.e. 
/// the message interface class defines mentioned earlier
/// types and functions.
///
/// @subsection page_use_prot_extra_transport_version Built-in Version Support
/// The @b COMMS library contain a built-in protocol version support when
/// version info is provided within @ref page_use_prot_extra_transport. To support
/// this feature, the
/// message interface definition class needs to use @ref comms::option::def::VersionInExtraTransportFields
/// option, in addition to @ref comms::option::def::ExtraTransportFields option itself, to
/// specify which field is @b version.
/// @code
/// namespace my_protocol
/// {
/// 
/// // Field describing protocol version.
/// using MyVersionField = comms::field::IntValue<...>;
///
/// // Relevant extra transport fields, bundled in std::tuple
/// using MyExtraTransportFields =
///     std::tuple<
///         MyVersionField
///     >;
///
/// template <typename... TOptions>
/// class Message : public
///     comms::Message<
///         comms::option::def::BigEndian,
///         comms::option::def::MsgIdType<MsgId>,
///         comms::option::def::ExtraTransportFields<MyExtraTransportFields>,
///         comms::option::def::VersionInExtraTransportFields<0>
///         TOptions...
///     >
/// {
///     ...
/// };
///
/// } // namespace my_protocol
/// @endcode
/// Usage of @ref comms::option::def::VersionInExtraTransportFields option generates
/// inner @b VersionType type (see @ref comms::Message::VersionType) as well
/// as @b version() access functions (see @ref comms::Message::version()) for direct
/// access to it. It is equivalent to having the following functions defined:
/// @code
/// namespace my_protocol
/// {
/// 
/// template <typename... TOptions>
/// class Message : public
///     comms::Message<...>
/// {
/// public:
///     ...
///     // Type of extra fields
///     using VersionType = ...; // Equals to ValueType of the relevant field.
///
///     // Accessors for the version info
///     VersionType& version();
///     const VersionType& version() const;
/// };
///
/// } // namespace my_protocol
/// @endcode
/// @b NOTE, that updating the version information only modifies the value
/// of the relevant transport fields itself. The message contents are not
/// being updated. There is a need to invoke @b doFieldsVersionUpdate() member
/// function (see @ref comms::MessageBase::doFieldsVersionUpdate()), 
/// which will do the job of updating message 
/// contents accordingly.
/// @code
/// using MyMessage1 = my_protocol::MyMessage<...>;
/// MyMessage1 msg;
/// msg.version() = 5U; // Update the version
/// msg.doFieldsVersionUpdate(); // Update the message contents that depend on version
/// @endcode 
/// The @b refresh functionality (direct or polymorphic) also contains update
/// of the fields' version, which can be used instead.
/// @code
/// void updateVersion(MyMessage& msg)
/// {
///     msg.version() = 5U;
///     msg.refresh(); // Polymorphically update the message contents accordingly
/// }
/// @endcode
///
/// @section page_use_prot_pseudo_transport Pseudo Transport Values
/// Some communication protocols have values (such as protocol version information),
/// which are reported in the payload of one of the messages and may influence
/// the way how other messages being deserialised and/or handled. Usually it is
/// some kind of @b CONNECT message. Such scenario is implemented in the
/// very similar way to @ref page_use_prot_extra_transport. The frame
/// is still defined using @ref comms::frame::TransportValueLayer but with @ref
/// comms::option::def::PseudoValue option. Such layer contains the "pseudo" field in
/// its internal data members and pretends to read it during @b read operation.
///
/// Let's assume the protocol framing is defined to be
/// @code
/// SIZE | ID | PAYLOAD
/// @endcode
/// but there is some kind of @b CONNECT message that reports client protocol version.
/// The transport framing will probably be defined as if it handles the following
/// values.
/// @code
/// SIZE | ID | VERSION (pseudo) | PAYLOAD
/// @endcode
/// The transport framing is expected to be defined as below providing an access
/// to the VERSION handling layer:
/// @code
/// namespace my_protocol
/// {
///
/// template <
///     typename TMessage, // common interface class defined by the application
///     typename TInputMessages = AllMessages<TMessage>, // Input messages that need to be recognised
///     typename TAllocationOptions = comms::option::app::EmptyOption // Extra options for MsgIdLayer
/// >
/// struct Frame : public 
///     MySizePrefix<TMessage, TInputMessages, TAllocationOptions> 
/// {
///     COMMS_FRAME_LAYERS_ACCESS(payload, version, id, size);
/// };
///
/// } // namespace my_protocol
/// @endcode
/// Then after reception and handling of the mentioned @b CONNECT message, the
/// stored pseudo version field may be accessed using @b pseudoField() member
/// function of @ref comms::frame::TransportValueLayer layer (see @ref
/// comms::frame::TransportValueLayer::pseudoField()) and updated with
/// reported value.
/// @code
/// MyFrame frame; // Frame object
/// frame.layer_version().pseudoField().value() = connectMsg.field_version().value();
/// @endcode
/// From now on every received message will have appropriate extra transport field
/// updated accordingly right after receiving of the message and before its @b
/// read operation being performed.
///
/// @section page_use_prot_msg_customisation Application Specific Customisation of Messages
/// When most of the messages are uni-directional, i.e. are either only sent or
/// only received, then it may make sense to split the common message interface
/// class @b MyMessage (see @ref page_use_prot_interface) into two 
/// interface classes: for @b input and for @b output. It will save the generation
/// of unnecessary virtual functions which are not used, but occupy space.
/// @code
/// using MyInputMessage = 
///     my_protocol::Message<
///         comms::option::app::ReadIterator<const std::uint8_t*>, // polymorphic read
///         comms::option::app::Handler<MyHandler> // polymorphic dispatch
///     >;
///
///  using MyOutputMessage = 
///     my_protocol::Message<
///         comms::option::app::WriteIterator<std::uint8_t*>, // polymorphic write
///         comms::option::app::IdInfoInterface, // polymorphic ID retrieve
///         comms::option::app::LengthInfoInterface // polymorphic serialisation length retrieve
///     >;
///
/// using MyInputMessage1 = my_protocol::Message1<MyInputMessage>;
/// using MyInputMessage2 = my_protocol::Message2<MyInputMessage>;
/// using MyInputMessage3 = my_protocol::Message3<MyInputMessage>;
/// ...
///
/// using MyOutputMessage7 = my_protocol::Message7<MyOutputMessage>;
/// using MyOutputMessage8 = my_protocol::Message8<MyOutputMessage>;
/// using MyOutputMessage9 = my_protocol::Message9<MyOutputMessage>;
/// ...
///
/// @endcode
/// There may be also an opposite case, when most of the messages are bi-directional,
/// while only few go one way. For most applications the single common
/// message interface will do the job. However generating unnecessary virtual
/// functions for bare-metal application may be a heavy price to pay, especially
/// when ROM size is small. The @b COMMS library provides several
/// options that inhibit generation of virtual functions. These extra options 
/// need to be passed to @ref comms::MessageBase class when defining a message 
/// class. Available options are:
/// @li @ref comms::option::app::NoReadImpl
/// @li @ref comms::option::app::NoWriteImpl
/// @li @ref comms::option::app::NoValidImpl
/// @li @ref comms::option::app::NoLengthImpl
/// @li @ref comms::option::app::NoDispatchImpl
///
/// In order to be able to pass these extra options to message definition classes,
/// the support from the latter is required. If the protocol definition
/// follows a recommended approach the message definition is expected to
/// reuse extra protocol options structure (@b DefaultOptions) described earlier.
/// @code
/// namespace my_protocol
/// {
///
/// // Allow passing extra options to messages as well
/// struct DefaultOptions
/// {
///     struct message
///     {
///         using Message1 = comms::option::app::EmptyOption;
///         using Message2 = comms::option::app::EmptyOption;
///         ...
///     };
/// };
/// 
/// namespace message
/// {
///
/// template <typename TBase, typename TOpt = DefaultOptions>
/// class Message1 : public 
///     comms::MessageBase<
///         TBase, 
///         comms::option::def::StaticNumIdImpl<MsgId_Message1>,
///         comms::option::def::FieldsImpl<Message1Fields<TOpt>::All>,
///         comms::option::def::MsgType<Message1<TBase, TOpt> >,
///         typename TOpt::message::Message1 // Extra options 
///     >
/// {
///     ...
/// };
///
/// } // namespace message
///
/// } // namespace my_protocol
/// @endcode
/// As an example let's assume, that @b Message1 is only sent by the
/// application, but never received, and @b Message 2 is the opposite, only
/// received by never sent. In this case defining the following options
/// structure and passing them in to message definition classes will work
/// @code
/// struct MyOptions : public my_protocol::DefaultOptions
/// {
///     struct message : public my_protocol::DefaultOptions::message
///     {
///         using Message1 = comms::option::app::NoReadImpl;
///         using Message2 = comms::option::app::NoWriteImpl;
///     };
/// };
///
/// using MyMessage1 = my_protocol::Message1<MyMessage, MyOptions>;
/// using MyMessage2 = my_protocol::Message2<MyMessage, MyOptions>;
/// @endcode
///
/// @section page_use_prot_msg_extension Message Interface Extension
/// Sometimes the public interface of the messages, generated by the
/// @b COMMS library out of available options passed to @ref comms::Message,
/// may be insufficient for some applications and its interface needs to be extended
/// with custom member functions. It is easy to achieve by
/// just implementing required function in common message interface class
/// @code
/// class MyMessage : public my_protocol::Message<...>
/// {
/// public:
///     void someFunc()
///     {
///         someFuncImpl();
///     }
///
/// protected:
///     virtual void someFuncImpl() = 0;
/// };
/// @endcode
/// All the protocol messages must also be extended in order to implement
/// missing virtual function
/// @code
/// class MyMessage1 : public my_protocol::Message1<MyMessage>
/// {
/// protected:
///     virtual void someFuncImpl() override
///     {
///         ...
///     }
/// };
/// @endcode
/// Don't forget to bundle newly defined messages in @b std::tuple and pass 
/// them to @ref page_use_prot_transport definition or @ref page_use_prot_handling_generic
/// when needed.
/// @code
/// using MyInputMessages = 
///     std::tuple<
///         MyMessage1, 
///         MyMessage2,
///         ...
///     >;
///
/// using MyFrame = my_protocol::Frame<MyMessage, MyInputMessages>;
/// using MyHandler = comms::GenericHandler<MyMessage, MyInputMessages>;
/// ...
/// @endcode
///
