/// @page page_frame_tutorial Frame Definition Tutorial
/// @tableofcontents
/// @section page_frame_tutorial_intro Introduction
/// In addition to definition of the messages and their contents, every 
/// communication protocol must ensure that the message is successfully delivered
/// over the I/O link to the other side. The serialised message payload must
/// be wrapped in some kind of transport information prior to being sent and 
/// unwrapped on the other side when received.
///
/// For example, let's define a custom protocol that wraps the message payload
/// in the following way:
/// @code
/// SYNC | SIZE | ID | PAYLOAD | CHECKSUM 
/// @endcode    
/// where:
/// @li SYNC - 2 bytes of synchronisation value to indicate beginning of the message, 
///     must be "0xab 0xcd"
/// @li SIZE - 2 bytes, length of remaining data including checksum and not 
///     including SIZE field itself.
/// @li ID - 1 byte, numeric ID of the message.
/// @li PAYLOAD - any number of bytes, serialised message data
/// @li CHECKSUM - 2 bytes, CRC-CCITT value of all bytes starting (and
///     including) from SIZE field and ending after PAYLOAD field.
/// 
/// The processing of the raw bytes received over I/O link involves identifying
/// the fields listed above and stripping them off <b>one by one</b> until the
/// @b PAYLOAD is reached, where it can be read by the created proper message
/// object (based on read message ID). If one of the elements is not as it is 
/// expected to be, the processing should stop.
///
/// The sequential processing the the transport information values, and stripping
/// them one by one before proceeding to the next one, may remind of 
/// <a href="https://en.wikipedia.org/wiki/OSI_model">OSI Conceptual Model</a>, where
/// a layer serves the layer above it and is served by the layer below it. 
///
/// The @b COMMS library defines every such @b layer, that is handling a single
/// value, as separate class. Every such layer class will use @b field abstraction
/// (see @ref page_field_tutorial) to wrap the value it handles.
/// The layer classes are stacked together by wrapping
/// one another. When combined together they are called <b>Frame</b>.
///
/// The wrapping for the example above will look like this:
/// @diafile frame.dia
///
/// When presented as actual stack, it may look like this:
/// @diafile frame_layers.dia
///
/// Please note that @b CHECKSUM layer lays between @b SYNC and @b SIZE. This is
/// a bit counter intuitive, because @b SIZE follows @b SYNC in the protocol
/// description, while @b CHECKSUM appears last. The reason for such location
/// of @b CHECKSUM layer is that it calculates and verifies checksum on the
/// @b SIZE, @b ID, and @b PAYLOAD areas, i.e. it must wrap the all three.
///
/// The COMMS library provides multiple classes to define various layers when
/// assembling the full <b>frame</b> of layers. All these classes reside in
/// comms::frame namespace.
/// The following sections will cover all the layer classes required to
/// assemble the frame described above.
///
/// @section page_frame_tutorial_payload PAYLOAD Layer
/// The top layer, that is responsible to read/write the payload of the message
/// is called @b PAYLOAD. It is implemented by comms::frame::MsgDataLayer
/// class in the COMMS library. 
/// @code
/// using MyMsgData = comms::frame::MsgDataLayer<>;
/// @endcode
/// @b NOTE, that @ref comms::frame::MsgDataLayer receives a template parameter of the extending options.
/// In the normal operation, when transport frame fields are not stored anywhere,
/// it is never used. However, there is way to perform @b read operation while
/// caching transport fields (by using @ref comms::frame::MsgDataLayer::readFieldsCached() "readFieldsCached()")
/// The default payload field is defined to be @b comms::field::ArrayList of raw data
/// (see @ref comms::frame::MsgDataLayer::Field). It is possible to override
/// the default definition of some other variant of the @b comms::field::ArrayList:
/// @code
/// using CustomDataField = comms::field::ArrayList<...>;
///
/// using MyMsgData = comms::frame::MsgDataLayer<comms::option::def::FieldType<CustomDataField>>;
/// @endcode
///
/// @section page_frame_tutorial_id ID Layer
/// The @b ID layer is responsible to process the ID of the message
/// and based on this ID, create proper message object. The COMMS library implements
/// this functionality in comms::frame::MsgIdLayer class. It receives 
/// <b>at least</b> four template parameters. The first one is a type of the
/// field that can be used to read/write the ID information. The @ref
/// page_define_prot_interface section described @b my_protocol::MsgId enum
/// type used to define message IDs, it can be reused to define a field responsible
/// to read / write message ID value 
/// @code
/// namespace my_protocol
/// {
///
/// enum MsgId : std::uint8_t {...} // enum described earlier
///
/// using MyFieldBase = comms::Field<comms::option::def::BigEndian>; // Use big endian for all fields serialisation
///
/// using MsgIdField = 
///     comms::field::EnumValue<
///         MyFieldBase, 
///         MsgId // enum type
///     >;
///
/// } // namespace my_protocol
/// @endcode
/// @b NOTE, that underlying enum type is defined to be @b std::uint8_t, which
/// will result in 1 byte serialisation length.
///
/// The second parameter is common interface class for all @b input messages
/// that need to be recognised during @b read operation. This type will be defined
/// by the application and is expected to be an alias (typedef) or extending 
/// class to @b my_protocol::Message (described in @ref page_define_prot_interface)
/// 
/// The third parameter
/// is all the types of all the custom messages, that need to be recognised in
/// @b read operation, bundled in std::tuple. 
/// @code
/// template <typename TMessage>
/// using AllMessages =
///     std::tuple<
///         Message1<TMessage>,
///         Message2<TMessage>,
///         Message3<TMessage>,
///         ...
///     >;
/// @endcode
/// @b NOTE, that the interface class (@b TMessage) passed as
/// the second parameter is expected to be the common base class for all the messages
/// passed as third one.
/// 
/// The fourth template parameter is the upper layer it needs to wrap:
/// @code
/// template <
///     typename TMessage, // common interface class defined by the application
///     typename TInputMessages = AllMessages<TMessage> // Input messages that need to be recognised
/// >
/// using MyMsgId = 
///     comms::frame::MsgIdLayer<
///         MsgIdField, 
///         TMessage, 
///         TInputMessages, 
///         MyMsgData<>
///     >;
/// @endcode 
/// @b NOTE, that all the input messages are passed as a template parameter with
/// a default value (bundling all the available messages). It will give an opportunity
/// to the application to use only messages it needs.
///
/// Also @b note, input messages in the bundle (@b TInputMessages) are expected
/// to be defined in order of their numeric IDs. It is allowed to have separate
/// message classes to report the same numeric ID. However, the @b read operation will
/// try to read all the messages with the found ID one by one <b>in
/// order</b> of their definition until success is reported.
///
/// The comms::frame::MsgIdLayer defines @ref comms::frame::MsgIdLayer::MsgPtr "MsgPtr"
/// internal type, which is
/// smart pointer (@b std::unique_ptr) to the input message interface
/// class (@b TMessage) provided as second template parameter.
///
/// During the normal @b read operation, the comms::frame::MsgIdLayer will
/// dynamically allocate the proper message object.
///
/// The comms::frame::MsgIdLayer can also be used in <b>bare metal</b> systems,
/// that do NOT use dynamic memory allocation. In order to prevent this layer 
/// from using dynamic memory allocation, the @ref comms::option::app::InPlaceAllocation
/// option needs to be passed as fifth template parameter to the
/// comms::frame::MsgIdLayer class. However, an ability to use this option
/// needs to be provided to the application itself only if needed. In order to
/// achive that additional template parameter needs to be used.
/// @code
/// template <
///     typename TMessage, // common interface class defined by the application
///     typename TInputMessages = AllMessages<TMessage>, // Input messages that need to be recognised
///     typename TAllocationOptions = comms::option::app::EmptyOption // Extra options for MsgIdLayer
/// >
/// using MyMsgId = 
///     comms::frame::MsgIdLayer<
///         MsgIdField, 
///         TMessage, 
///         TInputMessages, 
///         MyMsgData<>,
///         TAllocationOptions
///     >;
/// @endcode 
/// In this case, the comms::frame::MsgIdLayer will statically allocate 
/// internal buffer in its private data members, big enough to hold any message object
/// of any type listed in @b AllMessages bundle. It means that only one message
/// object can be allocated and used at a time, i.e. the previous object must
/// be deleted prior to new one being allocated. @n
/// Also, the @ref comms::frame::MsgIdLayer::MsgPtr "MsgPtr" will still be a variant of
/// @b std::unique_ptr, but with custom deleter (defined by COMMS library itself),
/// which will make sure the proper destruction of the message object and
/// release of the internal buffer for next allocation. In case new allocation
/// is attempted when internal buffer is NOT released, the new message will NOT be allocated
/// and read operation will fail with @ref comms::ErrorStatus::MsgAllocFailure
/// error.
///
/// By default, if the received data contains unknown message ID (the message
/// type is not in @b AllMessages bundle), the @b read operation returns
/// @ref comms::ErrorStatus::InvalidMsgId and no message object is allocated.
/// However, there are @b bridge / @b gateway / @b firewall type of applications
/// which are interested to decode only limited number of messages, but still
/// forward the received data (sometimes changing the transport wrapping) 
/// without actually decoding the contents. In this case the default behaviour 
/// cannot be used. The @b COMMS library provides @ref comms::GenericMessage 
/// message definition which has a single variable length data field 
/// (defined using @ref comms::field::ArrayList class). The @ref
/// comms::frame::MsgIdLayer may also receive @ref comms::option::app::SupportGenericMessage
/// option specifying type of the GenericMessage. 
/// In this case, if the appropriate message type hasn't been found in 
/// @b AllMessages bundle, the appropriate @ref comms::GenericMessage object
/// will be created instead. However, just like with
/// @ref comms::option::app::InPlaceAllocation, this option should be used by the application
/// if needed.
///
/// Note, that @ref comms::option::app::SupportGenericMessage and @ref comms::option::app::InPlaceAllocation
/// options can be used together. In this case the @ref comms::GenericMessage
/// message object will be allocated in the same allocation area. The client
/// application will be able to combine these option together in single tuple
/// and use pass as @b TAllocationOptions parameter.
/// @code
/// using MyAllocOptions = 
///     std::tuple<
///         comms::option::app::SupportGenericMessage<comms::GenericMessage<MyInterfaceMessage> >,
///         comms::option::app::InPlaceAllocation
///     >;
/// @endcode
/// When constructed, the comms::frame::MsgIdLayer creates an array of
/// statically allocated factory methods, which are responsible to allocate
/// right message objects. This array is used as a map of message ID to the
/// factory method. The COMMS library contains inner logic that analyses a tuple of all @b input message
/// types provided to @ref comms::frame::MsgIdLayer. If the IDs of the messages
/// are sequential ones starting from a low number such as 0 or 1, and the highest
/// ID value do not significantly exceed the total number of message types in the tuple,
/// then the one-to-one mapping is generated, i.e. to access the right factory 
/// method is just accessing the right cell in the mapping array (O(1) time complexity).
/// In all other cases the factory methods are compacted together and binary search
/// is executed to get appropriate factory method having the numeric message ID 
/// value (O(log(n))).
///
/// @b NOTE, that comms::frame::MsgIdLayer doesn't use any dynamic memory
/// allocation to store internal factory methods, that create proper message
/// object given the ID of the message, which makes it possible and safe to
/// use in bare-metal environment without any HEAP.
///
/// It may happen that @b comms::frame::MsgIdLayer class as-is is not really
/// suitable for implementing message identification and creation of message
/// object when implementing custom protocol. 
/// It is possible to implement a new custom layer (see @ref
/// page_frame_tutorial_new_layers section below) with the required
/// functionality. However, it is recommended
/// to use @ref comms::MsgFactory object internally. It will help in creation the proper
/// message object once the ID value is known.
///
/// @section page_frame_tutorial_size SIZE Layer
/// The @b SIZE layer is responsible to process information on the remaining
/// message length, and forward the @b read/write operations to the upper layer
/// in case it is safe to do so. The COMMS library provides 
/// @ref comms::frame::MsgSizeLayer class for that purpose.
/// @code
/// namespace my_protocol
/// {
///
/// using RemSizeField =
///     comms::field::IntValue<
///         MyFieldBase, 
///         std::uint16_t, 
///         comms::option::def::NumValueSerOffset<sizeof(std::uint16_t)> 
///     >;
///
/// template <
///     typename TMessage, // common interface class defined by the application
///     typename TInputMessages = AllMessages<TMessage>, // Input messages that need to be recognised
///     typename TAllocationOptions = comms::option::app::EmptyOption // Extra options for MsgIdLayer
/// >
/// using MyMsgSize = 
///     comms::frame::MsgSizeLayer<
///         RemSizeField, 
///         MyMsgId<TMessage, TInputMessages, TAllocationOptions> 
///     >;
/// 
/// } // namespace my_protocol
/// @endcode
/// The @ref comms::frame::MsgSizeLayer receives <b>at least</b> two template parameters. The first
/// one is the definition of the @b field (see @ref page_field_tutorial for details)
/// that is responsible to read/write the remaining length information. The
/// second template parameter is an upper layer that is being wrapped. The third
/// template parameter is optional default behaviour modification options.@n
/// Please note the usage of @ref comms::option::def::NumValueSerOffset option when
/// defining the @b field type. If it is NOT used, the serialised length value
/// will cover only @b ID and @b PAYLOAD (layers it wraps). However, according to the protocol
/// specification, the @b SIZE value must also include @b CHECKSUM. Usage of
/// @ref comms::option::def::NumValueSerOffset <sizeof(std::uint16_t)> will add 2
/// (@b sizeof(std::uint16_t)) when serialising the length of wrapped fields.
/// See also @ref sec_field_tutorial_int_value_ser_offset for more details.
///
/// @section page_frame_tutorial_checksum CHECKSUM Layer
/// The @b CHECKSUM layer is responsible to calculate and verify the checksum
/// on the data read and/or written by the upper layers it wraps.
/// The COMMS library provides comms::frame::ChecksumLayer and
/// comms::frame::ChecksumPrefixLayer for this purpose. They are very similar.
/// The only difference is that comms::frame::ChecksumLayer appends the 
/// checksum value, while comms::frame::ChecksumPrefixLayer prepends it.
/// @code
/// namespace my_protocol
/// {
///
/// using ChecksumField = comms::field::IntValue<MyFieldBase, std::uint16_t>;
///
/// template <
///     typename TMessage, // common interface class defined by the application
///     typename TInputMessages = AllMessages<TMessage>, // Input messages that need to be recognised
///     typename TAllocationOptions = comms::option::app::EmptyOption // Extra options for MsgIdLayer
/// >
/// using MyChecksum =
///     comms::frame::ChecksumLayer<
///         ChecksumField,
///         comms::frame::checksum::Crc_CCITT
///         MyMsgSize<TMessage, TInputMessages, TAllocationOptions>
///     >;
/// 
/// } // my_protocol
/// @endcode
/// The both layer classes receives three template parameters. The
/// first one is a @b field that is responsible to read/write the checksum value.
///
/// The second template parameter is a checksum calculator class which is used
/// to calculate a checksum value. Please refer to the documentation of
/// @ref comms::frame::ChecksumLayer or @ref comms::frame::ChecksumPrefixLayer class 
/// for the details on the interface this
/// checksum calculator class must provide. The example above uses 
/// @ref comms::frame::checksum::Crc_CCITT, which calculates the the standard
/// CRC-CCITT value. All the checksum calculators the COMMS library provides reside
/// in comms::frame::checksum namespace. 
///
/// The third template parameter is an upper layer that is being wrapped.
///
/// By default both @ref comms::frame::ChecksumLayer and 
/// @ref comms::frame::ChecksumPrefixLayer allow inner (upper) layers to 
/// complete their read operation before calculating and verifying checksum on
/// read data. However, there may be protocols that may allow checksum verification
/// before attempting to read message contents. In this case 
/// @ref comms::option::def::ChecksumLayerVerifyBeforeRead option may be used as
/// fourth template parameter.
/// @code
/// namespace my_protocol
/// {
/// template <
///     typename TMessage, // common interface class defined by the application
///     typename TInputMessages = AllMessages<TMessage>, // Input messages that need to be recognised
///     typename TAllocationOptions = comms::option::app::EmptyOption // Extra options for MsgIdLayer
/// >
/// using MyChecksum =
///     comms::frame::ChecksumLayer<
///         ChecksumField,
///         comms::frame::checksum::Crc_CCITT
///         MyMsgSize<TMessage, TInputMessages, TAllocationOptions>,
///         comms::option::def::ChecksumLayerVerifyBeforeRead
///     >;
/// 
/// } // namespace my_protocol
/// @endcode
///
/// @section page_frame_tutorial_sync SYNC Layer
/// The @b SYNC layer is responsible to recognise the synchronisation byte(s)
/// in the input stream as well as write appropriate value when the write
/// operation takes place. The COMMS library provides @ref comms::frame::SyncPrefixLayer
/// class that helps with this task.
/// @code
/// namespace my_protocol
/// {
///
/// using SyncField =
///     comms::field::IntValue<
///         MyFieldBase, 
///         std::uint16_t, 
///         comms::option::def::DefaultNumValue<0xabcd>,
///         comms::option::def::ValidNumValue<0xabcd>,
///         comms::option::def::FailOnInvalid // fail read operation if read value is invalid 
///     >;
///
/// template <
///     typename TMessage, // common interface class defined by the application
///     typename TInputMessages = AllMessages<TMessage>, // Input messages that need to be recognised
///     typename TAllocationOptions = comms::option::app::EmptyOption // Extra options for MsgIdLayer
/// >
/// using MySyncPrefix = 
///     comms::frame::SyncPrefixLayer<
///         SyncField, 
///         MyChecksum<TMessage, TInputMessages, TAllocationOptions> 
///     >;
/// 
/// } // namespace my_protocol
/// @endcode
/// The comms::frame::SyncPrefixLayer class receives two template parameters.
/// The first one is the type of the @b field, that is responsible to read/write
/// the synchronisation byte(s). Please note the usage of @ref comms::option::def::DefaultNumValue
/// option when defining the @b field type. It insures that the default constructed
/// field will have the required value. @n
/// The second template parameter is the upper layer being wrapped.
///
/// @section page_frame_tutorial_transport_value Extra Transport Values
/// Some protocol may use extra values as part of the transport information. Such
/// values may have an influence on how the message payload is read and/or on
/// how the message object is handled. As an example let's define the following
/// transport wrapping:
/// @code
/// SIZE | ID | VERSION | PAYLOAD
/// @endcode
/// The @b VERSION value is expected to influence the "read" operation. The message
/// object may have some extra fields, which were introduced in later version of
/// the protocol, and it needs to take into account the provided @b VERSION info.
///
/// The COMMS library provides @ref comms::frame::TransportValueLayer to handle
/// such fields. @b HOWEVER it requires extra support from common message interface class.
/// The latter must use @ref comms::option::def::ExtraTransportFields option in order
/// to define expected interface (please refer to @ref page_define_prot_interface_extra_transport
/// for details).
///
/// The @ref comms::frame::TransportValueLayer class receives three 
/// template parameters. The first one is the field used to read / write the
/// value. The second parameter is index of the relevant extra transport field
/// in the @ref comms::Message::TransportFields tuple. And the third parameter
/// is the next layer.
///
/// The whole frame definition may look like this:
/// @code
/// // Base class of all the fields
/// using MyFieldBase = comms::Field<comms::option::def::BigEndian>;
///
/// // Field describing protocol version.
/// using MyVersionField = comms::field::IntValue<MyFieldBase, std::uint16_t>;
///
/// using MyMsgData = comms::frame::MsgDataLayer<>;
///
/// // Version control layer
/// template <
///     typename TMessage // common interface class defined by the application
/// >
/// using MyVersion = 
///     comms::frame::TransportValueLayer<
///         MyVersionField, 
///         TMessage::TransportFieldIdx_version, 
///         MyMsgData<>
///     >;
///
/// // Id handling layer
/// template <
///     typename TMessage, // common interface class defined by the application
///     typename TInputMessages = AllMessages<TMessage>, // Input messages that need to be recognised
///     typename TAllocationOptions = comms::option::app::EmptyOption // Extra options for MsgIdLayer
/// >
/// using MyMsgId = 
///     comms::frame::MsgIdLayer<
///         MsgIdField, 
///         TMessage, 
///         TInputMessages, 
///         MyVersion<TMessage>,
///         TAllocationOptions
///     >;
///
/// // Size handling layer
/// template <
///     typename TMessage, // common interface class defined by the application
///     typename TInputMessages = AllMessages<TMessage>, // Input messages that need to be recognised
///     typename TAllocationOptions = comms::option::app::EmptyOption // Extra options for MsgIdLayer
/// >
/// using MyMsgSize = 
///     comms::frame::MsgSizeLayer<
///         RemSizeField, 
///         MyMsgId<TMessage, TInputMessages, TAllocationOptions> 
///     >;
/// @endcode
/// @b NOTE, that in the example above @b VERSION layer follows @b ID. In this case
/// the message object is already created by the @b ID layer when @b VERSION
/// one performs its read operation. The latter may update the version information
/// inside the created message object. However, there may be cases when 
/// extra transport value precedes ID layer:
/// @code
/// SIZE | VERSION | ID | PAYLOAD
/// @endcode
/// The COMMS library is also capable of handling such case. It contains internal
/// "magic", which forces some layers to complete their read operation and
/// update created message object (if necessary) before
/// the read operation is forwarded to the final (PAYLOAD) layer.
///
/// Unfortunatelly there are layers (@ref comms::frame::ChecksumLayer,
/// @ref comms::frame::ChecksumPrefixLayer, and @ref comms::frame::MsgSizeLayer),
/// that cannot complete their read operation, without read of the PAYLOAD data
/// being complete as well. As the result these layers do not support being wrapped by 
/// @ref comms::frame::TransportValueLayer and will fail compilation with
/// static assert if such wrapping is attempted.
///
/// @section page_frame_tutorial_pseudo_transport_value Pseudo Transport Values
/// Some protocols may report one of the values (such as protocol version) in
/// one of the messages used to establish connection. After that, the reported
/// value may have influence on how other message contents are being read. Handling
/// such case is very similar to @ref page_frame_tutorial_transport_value.
/// The only difference is passing @ref comms::option::def::PseudoValue option to
/// @ref comms::frame::TransportValueLayer layer class. It will cause the 
/// transport value not actually being (de)serialised during @b read / @b write
/// operations. The pseudo field value is going to be stored as private member
/// of @ref comms::frame::TransportValueLayer and can be accessed (and updated) using
/// @ref comms::frame::TransportValueLayer::pseudoField() "pseudoField()" member function(s).
/// During the @b read operation the comms::frame::TransportValueLayer behaves
/// as if the value stored in this field was actually read.
/// @code
/// // Version control layer
/// template <
///     typename TMessage // common interface class defined by the application
/// >
/// using MyVersion = 
///     comms::frame::TransportValueLayer<
///         MyVersionField, 
///         TMessage::TransportFieldIdx_version, 
///         MyMsgData<>,
///         comms::option::def::PseudoValue
///     >;
/// @endcode
/// 
/// @section page_frame_tutorial_summary Layers Summary
/// The earlier examples show that layer classes wrap one another, which creates
/// the following picture:
/// @diafile frame.dia
///
/// The outermost (or bottom) layer defines a full <b>frame</b>. It 
/// should be typedef-ed or extended to avoid any confusion:
/// @code
/// template <
///     typename TMessage, // common interface class defined by the application
///     typename TInputMessages = AllMessages<TMessage>, // Input messages that need to be recognised
///     typename TAllocationOptions = comms::option::app::EmptyOption // Extra options for MsgIdLayer
/// >
/// using Frame = MySyncPrefix<TMessage, TInputMessages, TAllocationOptions> ;
/// @endcode
/// Every protocol layer provides an ability to access the next one using
/// @ref comms::frame::FrameLayerBase::nextLayer() "nextLayer()" member function.
/// It is strongly recommended to generate convenience access functions using
/// #COMMS_PROTOCOL_LAYERS_ACCESS() macro.
/// @code
/// template <
///     typename TMessage, // common interface class defined by the application
///     typename TInputMessages = AllMessages<TMessage>, // Input messages that need to be recognised
///     typename TAllocationOptions = comms::option::app::EmptyOption // Extra options for MsgIdLayer
/// >
/// struct Frame : public 
///     MySyncPrefix<TMessage, TInputMessages, TAllocationOptions> 
/// {
///     COMMS_PROTOCOL_LAYERS_ACCESS(payload, id, size, checksum, sync);
/// };
/// @endcode
/// It is equivalent to having the following member function being defined:
/// @code
/// template <
///     typename TMessage, // common interface class defined by the application
///     typename TInputMessages = AllMessages<TMessage>, // Input messages that need to be recognised
///     typename TAllocationOptions = comms::option::app::EmptyOption // Extra options for MsgIdLayer
/// >
/// struct Frame : public 
///     MySyncPrefix<TMessage, TInputMessages, TAllocationOptions> 
/// {
///     // Access to PAYLOAD layer
///     decltype(auto) layer_payload();
///
///     // Const access to PAYLOAD layer
///     decltype(auto) layer_payload() const;
///
///     // Access to ID layer
///     decltype(auto) layer_id();
///
///     // Const access to ID layer
///     decltype(auto) layer_id() const;
///
///     // Access to SIZE layer
///     decltype(auto) layer_size();
///
///     // Const access to SIZE layer
///     decltype(auto) layer_size() const;
///
///     // Access to CHECKSUM layer
///     decltype(auto) layer_checksum();
///
///     // Const access to CHECKSUM layer
///     decltype(auto) layer_checksum() const;
///
///     // Access to SYNC layer
///     decltype(auto) layer_sync();
///
///     // Const access to SYNC layer
///     decltype(auto) layer_sync() const;
/// };
/// @endcode
/// Please note the following:
/// @li Every provided name is prefixed with @b layer_.
/// @li The names inside the #COMMS_PROTOCOL_LAYERS_ACCESS() macro specify
/// innermost layer first and outermost one last. There is a convenience 
/// wrapper macro #COMMS_PROTOCOL_LAYERS_ACCESS_OUTER() which allows
/// listing in the opposite order (outermost first and innermost last).
///
/// <b style="color:red">WARNING:</b> Some compilers, such as @b clang or earlier
/// versions of @b gcc (v4.9 and earlier) may have problems compiling the 
/// #COMMS_PROTOCOL_LAYERS_ACCESS() macro
/// even though it contains valid C++11 code. If the compilation failure 
/// happens there is a need to define inner @b Base type which specifies exact type
/// of the frame base class.
/// @code
/// template <
///     typename TMessage, // common interface class defined by the application
///     typename TInputMessages = AllMessages<TMessage>, // Input messages that need to be recognised
///     typename TAllocationOptions = comms::option::app::EmptyOption // Extra options for MsgIdLayer
/// >
/// class Frame : public 
///     MySyncPrefix<TMessage, TInputMessages, TAllocationOptions> 
/// {
///     using Base = MySyncPrefix<TMessage, TInputMessages, TAllocationOptions>;
/// public:
///     COMMS_PROTOCOL_LAYERS_ACCESS(payload, id, size, checksum, sync);
/// };
/// @endcode
/// @b NOTE, that @b COMMS library also defines @b COMMS_MUST_DEFINE_BASE in
/// case the base class definition is needed (going to be used). If the developed
/// application is going to be multi-platform and compiled with various compilers
/// (some of which may warn about unused private type) it is possible to use 
/// the defined symbol to add / remove the definition of the @b Base member type.
/// @code
/// template <
///     typename TMessage, // common interface class defined by the application
///     typename TInputMessages = AllMessages<TMessage>, // Input messages that need to be recognised
///     typename TAllocationOptions = comms::option::app::EmptyOption // Extra options for MsgIdLayer
/// >
/// class Frame : public 
///     MySyncPrefix<TMessage, TInputMessages, TAllocationOptions> 
/// {
/// #ifdef COMMS_MUST_DEFINE_BASE
///     using Base = ...
/// #endif
/// public:
///     COMMS_PROTOCOL_LAYERS_ACCESS(payload, id, size, checksum, sync);
/// };
/// @endcode
/// Since **v5.2** the COMMS library defines #COMMS_PROTOCOL_LAYERS_NAMES() and
/// #COMMS_PROTOCOL_LAYERS_NAMES_OUTER() macros they are similar to
/// the #COMMS_PROTOCOL_LAYERS_NAMES() and #COMMS_PROTOCOL_LAYERS_NAMES_OUTER()
/// respectively, but also provide aliases to the layer types. However usage of these
/// macros requires inner **Base** type definition of the base class:
/// @code
/// template <
///     typename TMessage, // common interface class defined by the application
///     typename TInputMessages = AllMessages<TMessage>, // Input messages that need to be recognised
///     typename TAllocationOptions = comms::option::app::EmptyOption // Extra options for MsgIdLayer
/// >
/// class Frame : public
///     MySyncPrefix<TMessage, TInputMessages, TAllocationOptions>
/// {
///     // Base type definition is a requirement
///     using Base = MySyncPrefix<TMessage, TInputMessages, TAllocationOptions>
/// public:
///     COMMS_PROTOCOL_LAYERS_NAMES(payload, id, size, checksum, sync);
/// };
/// @endcode
/// It is equivalent to having the following types and member function being defined:
/// @code
/// template <
///     typename TMessage, // common interface class defined by the application
///     typename TInputMessages = AllMessages<TMessage>, // Input messages that need to be recognised
///     typename TAllocationOptions = comms::option::app::EmptyOption // Extra options for MsgIdLayer
/// >
/// struct Frame : public
///     MySyncPrefix<TMessage, TInputMessages, TAllocationOptions>
/// {
///     using Layer_payload = ...;
///     decltype(auto) layer_payload();
///     decltype(auto) layer_payload() const;
///
///     using Layer_id = ...;
///     decltype(auto) layer_id();
///     decltype(auto) layer_id() const;
///
///     using Layer_size = ...;
///     decltype(auto) layer_size();
///     decltype(auto) layer_size() const;
///
///     using Layer_checksum = ...;
///     decltype(auto) layer_checksum();
///     decltype(auto) layer_checksum() const;
///
///     using Layer_sync = ...;
///     decltype(auto) layer_sync();
///     decltype(auto) layer_sync() const;
/// };
/// @endcode
///
/// @section page_frame_tutorial_new_layers Implementing New Layers
/// Every protocol is unique, and there is a chance that COMMS library doesn't
/// provide all the necessary layer classes required to implement custom logic
/// of the protocol. The COMMS library allows implementation and usage of 
/// custom layers as long as it defines the required types and implements required
/// functions. 
///
/// Some of the available layers support extension of their default functionality.
/// Pleases check the following tutorial pages. In most cases it will be sufficient.
/// @li @ref page_custom_id_layer
/// @li @ref page_custom_size_layer
/// @li @ref page_custom_transport_value_layer
/// @li @ref page_custom_checksum_layer
/// @li @ref page_custom_sync_prefix_layer
///
/// In case absolutely new and independent frame layer needs to be
/// implemented, please follow the instructions below.
///
/// It is strongly recommended to inherit from comms::frame::FrameLayerBase
/// and implement missing functionality
/// @code
/// // Must receive the next layer type as template parameter
/// template <typename TField, typename TNextLayer>
/// class MyLayer : public 
///     comms::frame::FrameLayerBase<
///         TField, 
///         TNextLayer,
///         MyLayer<TField, TNextLayer>
///     >
/// {
/// public:
///     // Implement read
///     template <typename TMsg, typename TIter, typename TNextLayerReader>
///     comms::ErrorStatus doRead(
///         Field& field,
///         TMsg& msg, // can be either smart pointer (Frame::MsgPtr) or message object itself
///         TIter& iter,
///         std::size_t size,
///         std::size_t* missingSize,
///         TNextLayerReader&& nextLayerReader)
///     {
///         // read the field's value
///         auto es = field.read(iter, size);
///         if (es != comms::ErrorStatus::Success) {
///             return es;
///         }
///
///         ... // do something with field's value
///         
///         // forward the read to the next layer.
///         return nextLayerReader.read(msg, iter, size - field.length(), missingSize);
///     }
///
///     // Implement write
///     template <typename TMsg, typename TIter, typename TNextLayerWriter>
///     comms::ErrorStatus doWrite(
///         Field& field,
///         const TMsg& msg,
///         TIter& iter,
///         std::size_t size,
///         TNextLayerWriter&& nextLayerWriter) const
///     {
///         // Update field with appropriate value
///         field.value() = ...;
///     
///         // write the field
///         auto es = field.write(iter, size);
///         if (es != comms::ErrorStatus::Success) {
///             return es;
///         }
///     
///         // forward the write to the next layer
///         return nextLayerWriter.write(msg, iter, size - field.length());
///     }
/// };
/// @endcode
/// Note that the third template parameter to the comms::frame::FrameLayerBase
/// base class is the inheriting class itself.
///
/// The comms::frame::FrameLayerBase implements @ref 
/// comms::frame::FrameLayerBase::read() "read()" and @ref
/// comms::frame::FrameLayerBase::readFieldsCached() "readFieldsCached()" member functions which
/// are actual "read" interface, they invoke the @b doRead() member function implemented
/// the derived layer class, while providing the "nextLayerReader" object to be
/// used to forward the read operation to the next layer. The signature of the
/// @b nextLayerReader.read() function is the same as @ref 
/// comms::frame::FrameLayerBase::read() "read()". @b NOTE, that @b msg parameter
/// to the @b doRead() member function can be either reference to a smart pointer
/// (@ref comms::frame::FrameLayerBase::MsgPtr "MsgPtr") or a reference to the message
/// object itself (one that extends @ref comms::MessageBase). If the message object contents
/// need to be accessed, then it is necessary to know what exactly is passed as
/// @b msg parameter to the @b doRead() function. The @ref
/// comms::frame::FrameLayerBase::isMessageObjRef() "isMessageObjRef()" 
/// member function can be used to help in such task
/// and "tag dispatch idiom" can be used to perform right functionality.
/// @code
/// // Must receive the next layer type as template parameter
/// template <typename TField, typename TNextLayer>
/// class MyLayer : public comms::frame::FrameLayerBase<...>
/// {
///     using Base = comms::frame::FrameLayerBase<...>;
/// public:
///     // Implement read
///     template <typename TMsg, typename TIter, typename TNextLayerReader>
///     comms::ErrorStatus doRead(
///         Field& field,
///         TMsg& msg, // can be either smart pointer (Frame::MsgPtr) or message object itself
///         TIter& iter,
///         std::size_t size,
///         std::size_t* missingSize,
///         TNextLayerReader&& nextLayerReader)
///     {
///         // read the field's value
///         auto es = field.read(iter, size);
///         if (es != comms::ErrorStatus::Success) {
///             return es;
///         }
///
///         using Tag = typename std::conditional<
///             Base::template isMessageObjRef<typename std::decay<decltype(msg)>::type>(),
///             DirectObjectAccessTag,
///             SmartPointerTag
///         >
///
///         doSomething(field, msg, Tag()); // do something with field's value
///
///         // forward the read to the next layer.
///         return nextLayerReader.read(msg, iter, size - field.length(), missingSize);
///     }
/// 
/// private:
///     struct SmartPointerTag {};
///     struct DirectObjectAccessTag {};
///
///     template <typename TMsgPtr>
///     void doSomething(Field& field, TMsgPtr& msgPtr, SmartPointerTag)
///     {
///         msgPtr->someFunc(...) // access message object via pointer
///     }
///
///     template <typename TMsg>
///     void doSomething(Field& field, TMsg& msg, DirectObjectAccessTag)
///     {
///         msg.someFunc(...); // access message object directly
///     }
///
/// };
/// @endcode
///
/// In similar way comms::frame::FrameLayerBase implements @ref 
/// comms::frame::FrameLayerBase::write() "write()" and @ref
/// comms::frame::FrameLayerBase::writeFieldsCached() "writeFieldsCached()" member functions which
/// are actual "write" interface, they invoke the @b doWrite() member function implemented
/// the derived layer class, while providing the "nextLayerWriter" object to be
/// used to forward the read operation to the next layer. The signature of the
/// @b nextLayerWriter.write() function is the same as @ref 
/// comms::frame::FrameLayerBase::write() "write()". If the @b doWrite() function
/// requires modification to the used iterator (moving it back and force), it
/// must determine type of the iterators (using @b std::iterator_traits). In case
/// the used iterator is @b output one (not @b random-access), then such update
/// may be impossible. In this case the @b doWrite() function is expected to
/// write some dummy value and return @ref comms::ErrorStatus::UpdateRequired. 
/// It will indicate to the client application that invocation of @b update
/// functionality with random access iterator needs to follow the @b write operation.
///
/// The comms::frame::FrameLayerBase base class defines also "update"
/// interface functions @ref comms::frame::FrameLayerBase::update() "update()" and
/// @ref comms::frame::FrameLayerBase::updateFieldsCached() "updateFieldsCached()", which in the
/// similar way invoke @b doUpdate(). However, @ref
/// comms::frame::FrameLayerBase class provides a default implementation
/// of @ref comms::frame::FrameLayerBase::doUpdate() "doUpdate()"
/// member function, which does nothing, just advances the iterator. If there
/// is a need for a custom update functionality, please provide it in you
/// layer class by implementing the custom version of @b doUpdate() member function.
/// @code
/// // Must receive the next layer type as template parameter
/// template <typename TField, typename TNextLayer>
/// class MyLayer : public 
///     comms::frame::FrameLayerBase<
///         TField, 
///         TNextLayer,
///         MyLayer<TField, TNextLayer>
///     >
/// {
/// public:
///     ...
///     template <typename TIter, typename TNextLayerUpdater>
///     comms::ErrorStatus doUpdate(
///         Field& field,
///         TIter& iter,
///         std::size_t size,
///         TNextLayerUpdater&& nextLayerUpdater) const
///     {
///         // Update field with the new value and rewrite it to the output buffer
///         field.value() = ...; 
///         auto es = field.write(iter, size);
///         if (es != comms::ErrorStatus::Success) {
///             return es;
///         }
///
///         // forward the update to the next layer
///         return nextLayerUpdater.update(iter, size - field.length());
///     }
/// };
/// @endcode
/// The signature of the
/// @b nextLayerUpdater.update() function is the same as @ref 
/// comms::frame::FrameLayerBase::update() "update()".
///
/// There may be cases when update functionality requires also knowledge about
/// message object being written. In this case there is a need to provide overloaded
/// @b doUpdate() member function that receives message object as its first parameter.
/// @code
/// // Must receive the next layer type as template parameter
/// template <typename TField, typename TNextLayer>
/// class MyLayer : public 
///     comms::frame::FrameLayerBase<...>
/// {
/// public:
///     ...
///     template <typename TMsg, typename TIter, typename TNextLayerUpdater>
///     comms::ErrorStatus doUpdate(
///         const TMsg& msg,
///         Field& field,
///         TIter& iter,
///         std::size_t size,
///         TNextLayerUpdater&& nextLayerUpdater) const
///     {
///         ...
///     }
/// };
/// @endcode
/// 
/// If the new layer being implemented is similar to @ref comms::frame::MsgIdLayer,
/// i.e. creates message objects when id of the message is known, then it must
/// also override (hide) the inherited @ref comms::frame::FrameLayerBase::createMsg() "createMsg()"
/// and implement its own version:
/// @code
/// template <typename TField, typename TNextLayer>
/// class MyLayer : public 
///     comms::frame::FrameLayerBase<
///         TField, 
///         TNextLayer,
///         MyLayer<TField, TNextLayer>
///     >
/// {
/// public:
///     ...
///     MsgPtr createMsg(MsgIdParamType id, unsigned idx = 0)
///     {
///         return someInternalMsgFactory.createMsg(id, idx);
///     }
/// };
/// @endcode
///

